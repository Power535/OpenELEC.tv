diff -Naur kodi-15.2-02e7013/configure.ac kodi.work/configure.ac
--- kodi-15.2-02e7013/configure.ac	2016-04-16 20:13:58.666059951 +0200
+++ kodi.work/configure.ac	2016-04-07 07:26:45.304470110 +0200
@@ -1952,6 +1952,11 @@
         CFLAGS="$CFLAGS -DEGL_API_FB"
       fi
       ;;
+    *hisilicon*)
+      AC_CHECK_LIB([player], main, LIBS="$LIBS -lplayer -lhi_so -lsubdec", AC_MSG_ERROR($missing_library))
+      AC_CHECK_LIB([hi_sample_common], main, LIBS="$LIBS -lhi_msp -ljpeg6b -lhi_common", AC_MSG_ERROR($missing_library))
+      XB_ADD_CODEC([LIBHISICODEC], [hisilicon], [$codecs])
+      ;;
     *)
   esac
 done
diff -Naur kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h
--- kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h	2015-10-23 23:53:21.000000000 +0200
+++ kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h	2016-04-09 10:37:13.683011389 +0200
@@ -82,6 +82,14 @@
    *
    */
   virtual int Decode(uint8_t* pData, int iSize) = 0;
+#if defined(HAS_LIBHISICODEC)
+  virtual int Decode(uint8_t* pData, int iSize, double dts) { return 0; }
+  /*
+   * will be called by video player indicating the playback speed. see DVD_PLAYSPEED_NORMAL,
+   * DVD_PLAYSPEED_PAUSE and friends.
+   */
+  virtual void SetSpeed(int iSpeed) {};
+#endif
 
   /*
    * returns nr of bytes in decode buffer
diff -Naur kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecHisi.cpp kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecHisi.cpp
--- kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecHisi.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecHisi.cpp	2016-04-11 10:14:23.137061819 +0200
@@ -0,0 +1,156 @@
+
+/*
+ *      Copyright (C) 2010-2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "DVDAudioCodecHisi.h"
+#if 0
+#include "DVDClock.h"
+#include "DVDStreamInfo.h"
+#endif
+#include "HISIAudioCodec.h"
+#include "utils/log.h"
+
+#define __MODULE_NAME__ "DVDAudioCodecHisi"
+
+CDVDAudioCodecHisi::CDVDAudioCodecHisi(void) :
+  m_Codec(NULL)
+{
+}
+
+CDVDAudioCodecHisi::~CDVDAudioCodecHisi(void)
+{
+  Dispose();
+}
+
+bool CDVDAudioCodecHisi::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
+{
+  CLog::Log(LOGDEBUG, "CDVDAudioCodecHisi::Open: TODO");
+
+  m_hints = hints;
+  m_Codec = new CHisiAudioCodec();
+  if (!m_Codec)
+  {
+    CLog::Log(LOGERROR, "%s: Failed to create Hisi AudioCodec", __MODULE_NAME__);
+    return false;
+  }
+  m_opened = false;
+
+#if 1
+  if (!m_opened)
+  {
+    if (m_Codec && !m_Codec->OpenDecoder(m_hints))
+      CLog::Log(LOGERROR, "%s: Failed to open Hisi Audio Codec", __MODULE_NAME__);
+    m_opened = true;
+  }
+#endif
+
+  CLog::Log(LOGINFO, "%s: Opened Hisi AudioCodec", __MODULE_NAME__);
+  return true;
+}
+
+void CDVDAudioCodecHisi::Dispose()
+{
+  CLog::Log(LOGDEBUG, "CDVDAudioCodecHisi::Dispose: TODO");
+
+  if (m_Codec)
+  {
+    m_Codec->CloseDecoder();
+    delete m_Codec;
+    m_Codec = NULL;
+  }
+}
+
+int CDVDAudioCodecHisi::Decode(uint8_t* pData, int iSize, double dts)
+{
+  if (iSize <= 0) return 0;
+
+  // Handle Input, add demuxer packet to input queue, we must accept it or
+  // it will be discarded as DVDPlayerVideo has no concept of "try again".
+#if 0
+  if (!m_opened)
+  {
+    if (m_Codec && !m_Codec->OpenDecoder(m_hints))
+      CLog::Log(LOGERROR, "%s: Failed to open Hisi Audio Codec", __MODULE_NAME__);
+    m_opened = true;
+  }
+#endif
+  m_Codec->Decode(pData, iSize, dts);
+
+  return iSize;
+}
+
+void CDVDAudioCodecHisi::SetSpeed(int speed)
+{
+  m_Codec->SetSpeed(speed);
+}
+
+int CDVDAudioCodecHisi::GetData(uint8_t** dst)
+{
+  CLog::Log(LOGDEBUG, "CDVDAudioCodecHisi::GetData: TODO");
+  return 0;
+}
+
+void CDVDAudioCodecHisi::Reset()
+{
+  CLog::Log(LOGDEBUG, "CDVDAudioCodecHisi::Reset: TODO");
+
+}
+
+int CDVDAudioCodecHisi::GetChannels()
+{
+  return m_hints.channels;
+}
+
+CAEChannelInfo CDVDAudioCodecHisi::GetChannelMap()
+{
+  CLog::Log(LOGDEBUG, "CDVDAudioCodecHisi::GetChannelMap: TODO");
+
+}
+
+int CDVDAudioCodecHisi::GetSampleRate()
+{
+  return m_hints.samplerate;
+}
+
+enum AEDataFormat CDVDAudioCodecHisi::GetDataFormat()
+{
+  switch(m_hints.codec)
+  {
+	case CODEC_ID_AC3:
+	  return AE_FMT_AC3;
+
+	case CODEC_ID_DTS:
+	  return AE_FMT_DTS;
+
+	case CODEC_ID_EAC3:
+	  return AE_FMT_EAC3;
+
+	case CODEC_ID_TRUEHD:
+	  return AE_FMT_TRUEHD;
+
+	//case CAEStreamInfo::STREAM_TYPE_DTSHD:
+	//  return AE_FMT_DTSHD;
+
+	default:
+	  CLog::Log(LOGERROR, "%s: Unknown stream type", __MODULE_NAME__);
+	  return AE_FMT_INVALID; //Unknown stream type
+  }
+}
+
diff -Naur kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecHisi.h kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecHisi.h
--- kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecHisi.h	1970-01-01 01:00:00.000000000 +0100
+++ kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecHisi.h	2016-04-13 18:41:25.075993795 +0200
@@ -0,0 +1,72 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2010-2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#if 0
+#include <list>
+
+#include "system.h"
+#endif
+#include "DVDAudioCodec.h"
+#include "DVDStreamInfo.h"
+#include "cores/AudioEngine/Utils/AEAudioFormat.h"
+#include "cores/AudioEngine/Utils/AEStreamInfo.h"
+#include "cores/AudioEngine/Utils/AEBitstreamPacker.h"
+
+class CHisiAudioCodec;
+
+class CDVDAudioCodecHisi : public CDVDAudioCodec
+{
+public:
+  CDVDAudioCodecHisi();
+  virtual ~CDVDAudioCodecHisi();
+
+  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
+  virtual void Dispose();
+  virtual int Decode(uint8_t* pData, int iSize) { return Decode(pData, iSize, 0); }
+  virtual int Decode(uint8_t* pData, int iSize, double dts);
+  virtual void SetSpeed(int iSpeed);
+  virtual int  GetData(uint8_t** dst);
+  virtual void Reset();
+  virtual int  GetChannels               ();
+#if 0
+  virtual int  GetEncodedChannels        ();
+#endif
+  virtual CAEChannelInfo GetChannelMap       ();
+  virtual int  GetSampleRate             ();
+#if 0
+  virtual int  GetEncodedSampleRate      ();
+#endif
+  virtual enum AEDataFormat GetDataFormat();
+#if 0
+  virtual bool NeedPassthrough           () { return false;          }
+#endif
+  virtual const char* GetName            () { return "HisiAudio"; }
+#if 0
+  virtual int  GetBufferSize();
+#endif
+
+private:
+  CHisiAudioCodec       *m_Codec;
+  bool            m_opened;
+  CDVDStreamInfo  m_hints;
+};
+
diff -Naur kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Audio/HISIAudioCodec.cpp kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Audio/HISIAudioCodec.cpp
--- kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Audio/HISIAudioCodec.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Audio/HISIAudioCodec.cpp	2016-04-16 20:13:30.784009154 +0200
@@ -0,0 +1,1538 @@
+/*
+ *      Copyright (C) 2005-2011 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#if 0 //Spitzbube
+#include "system.h"
+#endif
+
+#include "HISIAudioCodec.h"
+
+#if 0 //Spitzbube
+#include "DynamicDll.h"
+#else
+#include "../Video/DllLibHiComm.h"
+#include "../Video/DllLibHiMpi.h"
+#include "../Video/DllLibHiSample.h"
+#endif
+
+#include "Application.h"
+#include "cores/dvdplayer/DVDClock.h"
+#if 0 //Spitzbube
+#include "cores/VideoRenderers/RenderManager.h"
+#include "settings/Settings.h"
+#endif //Spitzbube
+#include "utils/log.h"
+#if 0 //Spitzbube
+#include "utils/TimeUtils.h"
+
+#include <unistd.h>
+#include <queue>
+#include <vector>
+#include <signal.h>
+#include <semaphore.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#endif //Spitzbube
+
+#define PTS_FREQ         1000000 //90000
+#define PTS_FREQ_MS	  1000 //90
+
+#define RW_WAIT_TIME    (20 * 1000) // 20ms
+
+#define P_PRE           (0x02000000)
+#define F_PRE           (0x03000000)
+#define PLAYER_SUCCESS          (0)
+#define PLAYER_FAILED           (-(P_PRE|0x01))
+#define PLAYER_NOMEM            (-(P_PRE|0x02))
+#define PLAYER_EMPTY_P          (-(P_PRE|0x03))
+
+#define PLAYER_WR_FAILED        (-(P_PRE|0x21))
+#define PLAYER_WR_EMPTYP        (-(P_PRE|0x22))
+#define PLAYER_WR_FINISH        (P_PRE|0x1)
+
+#define PLAYER_PTS_ERROR        (-(P_PRE|0x31))
+#define PLAYER_UNSUPPORT        (-(P_PRE|0x35))
+#define PLAYER_CHECK_CODEC_ERROR  (-(P_PRE|0x39))
+
+#define HDR_BUF_SIZE 1024
+typedef struct hdr_buf {
+    char *data;
+    int size;
+} hdr_buf_t;
+
+typedef struct hisi_packet {
+    AVPacket      avpkt;
+    double          avpts;
+    double          avdts;
+    int                avduration;
+    int                isvalid;
+    int                newflag;
+    double          lastpts;
+    unsigned char *data;
+    unsigned char *buf;
+    int                data_size;
+    int                buf_size;
+    hdr_buf_t     *hdr;
+    codec_para_t  *codec;
+    int                nchannels;
+    int                samplerate;
+} hisi_packet_t;
+
+typedef enum {
+    HISI_STREAM_UNKNOWN = 0,
+    HISI_STREAM_TS,
+    HISI_STREAM_PS,
+    HISI_STREAM_ES,
+    HISI_STREAM_RM,
+    HISI_STREAM_AUDIO,
+    HISI_STREAM_VIDEO,
+} pstream_type;
+
+typedef union {
+    int64_t      total_bytes;
+    unsigned int vpkt_num;
+    unsigned int spkt_num;
+} read_write_size;
+
+typedef  struct {
+    unsigned int read_end_flag: 1;
+    unsigned int end_flag: 1;
+    unsigned int reset_flag: 1;
+    int check_lowlevel_eagain_cnt;
+} p_ctrl_info_t;
+
+typedef struct hisi_private_t
+{
+  hisi_packet_t    hisi_pkt;
+  unsigned int      audio_codec_id;
+
+  pstream_type   stream_type;
+  p_ctrl_info_t     playctrl_info;
+
+  read_write_size   read_size;
+  read_write_size   write_size;
+  int                   check_first_pts;
+
+  int               extrasize;
+  uint8_t           *extradata;
+
+  DllLibHiSample     *m_dll_sample;
+  DllLibHiComm      *m_dll_comm;
+  DllLibHiMpi           *m_dll_mpi;
+
+  unsigned int m_hAvplay;
+  bool m_preloading_done;
+} hisi_private_t;
+
+#if 0 //Spitzbube
+struct buf_status {
+    int size;
+    int data_len;
+    int free_len;
+    unsigned int read_pointer;
+    unsigned int write_pointer;
+};
+#endif //Spitzbube
+
+extern unsigned int g_m_hAvplay;
+
+extern double g_m_hvsync;
+extern double g_m_hasync;
+
+static int aac_add_header(unsigned char *buf, int size, hisi_packet_t *pkt);
+#if 0 //Spitzbube
+static int mp3_add_header(unsigned char *buf, int size, hisi_packet_t *pkt);
+#endif
+
+static void hisi_packet_init(hisi_packet_t *pkt)
+{
+  memset(&pkt->avpkt, 0, sizeof(AVPacket));
+  pkt->avpts      = 0;
+  pkt->avdts      = 0;
+  pkt->avduration = 0;
+  pkt->isvalid    = 0;
+  pkt->newflag    = 0;
+  pkt->lastpts    = 0;
+  pkt->data       = NULL;
+  pkt->buf        = NULL;
+  pkt->data_size  = 0;
+  pkt->buf_size   = 0;
+  pkt->hdr        = NULL;
+  pkt->codec      = NULL;
+}
+
+static void hisi_packet_release(hisi_packet_t *pkt)
+{
+  if (pkt->buf != NULL)
+  {
+    free(pkt->buf);
+    pkt->buf= NULL;
+  }
+  if (pkt->hdr != NULL)
+  {
+    free(pkt->hdr->data);
+    pkt->hdr->data = NULL;
+    free(pkt->hdr);
+    pkt->hdr = NULL;
+  }
+  pkt->codec = NULL;
+}
+
+static int check_in_pts(hisi_private_t *para, hisi_packet_t *pkt)
+{
+    int last_duration = 0;
+    static int last_v_duration = 0;
+    double pts = 0;
+
+    last_duration = last_v_duration;
+
+    if (para->stream_type == HISI_STREAM_ES) {
+        if ((double)AV_NOPTS_VALUE != pkt->avpts) {
+            pts = pkt->avpts;
+/*
+            if (para->m_dll->codec_checkin_pts(pkt->codec, pts) != 0) {
+                CLog::Log(LOGDEBUG, "ERROR check in pts error!");
+                return PLAYER_PTS_ERROR;
+            }
+*/
+
+        } else if ((double)AV_NOPTS_VALUE != pkt->avdts) {
+            pts = pkt->avdts * last_duration;
+/*
+            if (para->m_dll->codec_checkin_pts(pkt->codec, pts) != 0) {
+                CLog::Log(LOGDEBUG, "ERROR check in dts error!");
+                return PLAYER_PTS_ERROR;
+            }
+*/
+            last_v_duration = pkt->avduration ? pkt->avduration : 1;
+        } else {
+            if (!para->check_first_pts) {
+		/*
+                if (para->m_dll->codec_checkin_pts(pkt->codec, 0) != 0) {
+                    CLog::Log(LOGDEBUG, "ERROR check in 0 to video pts error!");
+                    return PLAYER_PTS_ERROR;
+                }
+                */
+            }
+        }
+        if (!para->check_first_pts) {
+            para->check_first_pts = 1;
+        }
+    }
+    if (pts > 0)
+      pkt->lastpts = pts;
+
+//CLog::Log(LOGDEBUG, "lastpts: (%f)(%f)(%f)(%f)", pkt->lastpts, pts, pkt->avpts, pkt->avdts);
+    return PLAYER_SUCCESS;
+}
+
+static int check_write_finish(hisi_private_t *para, hisi_packet_t *pkt)
+{
+    if (para->playctrl_info.read_end_flag) {
+        if ((para->write_size.vpkt_num == para->read_size.vpkt_num)) {
+            return PLAYER_WR_FINISH;
+        }
+    }
+    return PLAYER_WR_FAILED;
+}
+
+static int write_header(hisi_private_t *para, hisi_packet_t *pkt)
+{
+	int ret = -1;
+
+	if (pkt->newflag)
+	{
+		if (para->audio_codec_id == HA_AUDIO_ID_AAC)
+		{
+			ret = aac_add_header(para->extradata, para->extrasize, pkt);
+			if (ret != PLAYER_SUCCESS) {
+				if (pkt->hdr)
+					pkt->hdr->size = 0;
+			}
+		}
+		/*
+		else if (para->audio_codec_id == HA_AUDIO_ID_MP3)
+		{
+			ret = mp3_add_header(para->extradata, para->extrasize, pkt);
+			if (ret != PLAYER_SUCCESS) {
+				if (pkt->hdr)
+					pkt->hdr->size = 0;
+			}
+		}
+		*/
+		else
+		{
+			pkt->hdr->data = NULL;
+		}
+	}
+
+
+    return PLAYER_SUCCESS;
+}
+
+static int check_avbuffer_enough(hisi_private_t *para, hisi_packet_t *pkt)
+{
+    return 1;
+}
+
+static int write_a_packet(hisi_private_t *para, hisi_packet_t *pkt)
+{
+	//CLog::Log(LOGDEBUG, "write_a_packet, pkt->isvalid(%d), pkt->data(%p), pkt->data_size(%d)",
+	//  pkt->isvalid, pkt->data, pkt->data_size);
+
+	int write_bytes = 0, len = 0, ret;
+	unsigned char *buf;
+	int size, wsize;
+
+	if (pkt->newflag) {
+		if (pkt->isvalid) {
+			ret = check_in_pts(para, pkt);
+			if (ret != PLAYER_SUCCESS) {
+				CLog::Log(LOGDEBUG, "check in pts failed");
+				return PLAYER_WR_FAILED;
+			}
+		}
+
+		if (pkt->hdr == NULL) {
+			pkt->hdr = (hdr_buf_t*)malloc(sizeof(hdr_buf_t));
+		}
+
+		if (pkt->hdr)
+			pkt->hdr->size = 0;
+
+		if (write_header(para, pkt) == PLAYER_WR_FAILED) {
+			CLog::Log(LOGDEBUG, "[%s]write header failed!", __FUNCTION__);
+			return PLAYER_WR_FAILED;
+		}
+
+		pkt->newflag = 0;
+	}
+
+	buf = pkt->data;
+	size = pkt->data_size ;
+	if (size == 0 && pkt->isvalid) {
+		para->write_size.vpkt_num++;
+		pkt->isvalid = 0;
+	}
+
+	while (size > 0 && pkt->isvalid) {
+		HI_S32 Ret;
+		HI_UNF_STREAM_BUF_S StreamBuf;
+		HI_U32 u32PtsMs;
+
+		if (pkt->hdr && pkt->hdr->size > 0)
+			wsize = size + pkt->hdr->size;
+		else
+			wsize = size;
+		//CLog::Log(LOGDEBUG, "write_a_packet 3, size 0x%x", wsize);
+		Ret = para->m_dll_mpi->HI_UNF_AVPLAY_GetBuf(para->m_hAvplay, HI_UNF_AVPLAY_BUF_ID_ES_AUD, wsize, &StreamBuf, 0);
+
+		if (HI_SUCCESS == Ret)
+		{
+			//CLog::Log(LOGDEBUG, "vpts %f", pkt->avpts);
+			if (pkt->hdr && pkt->hdr->size > 0)
+			{
+				memcpy((char *)StreamBuf.pu8Data, pkt->hdr->data, pkt->hdr->size);
+				memcpy((char *)&StreamBuf.pu8Data[pkt->hdr->size], buf, size);
+			}
+			else
+				memcpy((char *)StreamBuf.pu8Data, buf, wsize);
+
+#if 0  //Spitzbube: TODO
+			if ((double)AV_NOPTS_VALUE != pkt->avpts)
+				u32PtsMs = (HI_U32)(pkt->avpts/PTS_FREQ_MS);
+			else
+				u32PtsMs = (HI_U32)(pkt->avdts/PTS_FREQ_MS);
+#else
+			u32PtsMs = 0;
+#endif
+
+			Ret = para->m_dll_mpi->HI_UNF_AVPLAY_PutBuf(para->m_hAvplay, HI_UNF_AVPLAY_BUF_ID_ES_AUD, wsize, u32PtsMs);
+			if (HI_SUCCESS == Ret)
+			{
+				write_bytes = wsize;
+			}
+			else
+			{
+				CLog::Log(LOGDEBUG, "write_a_packet 5, ret 0x%x", Ret);
+				write_bytes = -1;
+			}
+		}
+		else
+		{
+			CLog::Log(LOGDEBUG, "write_a_packet 4, ret 0x%x", Ret);
+			write_bytes = -1;
+		}
+
+		if (pkt->hdr) {
+			if (pkt->hdr->data) {
+				free(pkt->hdr->data);
+				pkt->hdr->data = NULL;
+			}
+			free(pkt->hdr);
+			pkt->hdr = NULL;
+		}
+
+		//write_bytes = para->m_dll->codec_write(pkt->codec, (char *)buf, size);
+		if (write_bytes < 0 || write_bytes > wsize) {
+			if (0 /*-errno != AVERROR(EAGAIN)*/) {
+				para->playctrl_info.check_lowlevel_eagain_cnt = 0;
+				CLog::Log(LOGDEBUG, "write codec data failed!");
+				return PLAYER_WR_FAILED;
+			} else {
+				// EAGAIN to see if buffer full or write time out too much
+				if (check_avbuffer_enough(para, pkt)) {
+					para->playctrl_info.check_lowlevel_eagain_cnt++;
+				} else {
+					para->playctrl_info.check_lowlevel_eagain_cnt = 0;
+				}
+
+				if (para->playctrl_info.check_lowlevel_eagain_cnt > 50) {
+					// reset decoder
+					para->playctrl_info.check_lowlevel_eagain_cnt = 0;
+					para->playctrl_info.reset_flag = 1;
+					para->playctrl_info.end_flag = 1;
+					CLog::Log(LOGDEBUG, "$$$$$$ write blocked, need reset decoder!$$$$$$");
+				}
+				//pkt->data += len;
+				//pkt->data_size -= len;
+				usleep(RW_WAIT_TIME);
+				CLog::Log(LOGDEBUG, "usleep(RW_WAIT_TIME), len(%d)", len);
+				return PLAYER_SUCCESS;
+			}
+		}
+		else {
+			para->playctrl_info.check_lowlevel_eagain_cnt = 0;
+			len += write_bytes;
+			if (len >= pkt->data_size) {
+				para->write_size.vpkt_num++;
+				pkt->isvalid = 0;
+				pkt->data_size = 0;
+				break;
+			} else {
+				return PLAYER_WR_FAILED;
+			}
+		}
+	}
+
+	if (pkt->hdr) {
+		if (pkt->hdr->data) {
+			free(pkt->hdr->data);
+			pkt->hdr->data = NULL;
+		}
+		free(pkt->hdr);
+		pkt->hdr = NULL;
+	}
+
+	if (check_write_finish(para, pkt) == PLAYER_WR_FINISH) {
+		return PLAYER_WR_FINISH;
+	}
+
+	return PLAYER_SUCCESS;
+}
+
+#define AAC_HEADER_LENGTH       7
+
+static unsigned char DefaultAACHeader[]    =  {
+  0xff,
+  0xf1,
+  /*0x00, 0x00*/0x59/*0x50*/,  //((Profile & 0x03) << 6)  | (SampleIndex << 2) | ((Channels >> 2) & 0x01);s
+  0x80,                //(Channels & 0x03) << 6;
+  0x00,
+  0x1f,
+  0xfc
+};
+
+static int aac_add_header(unsigned char *buf, int size, hisi_packet_t *pkt)
+{
+	//unsigned char PesHeader[PES_MAX_HEADER_SIZE];
+	unsigned int  HeaderLength;
+	unsigned char* PacketStart;
+	unsigned char ExtraData[AAC_HEADER_LENGTH];
+	unsigned int  PacketLength;
+	unsigned char* p;
+	unsigned char* extradata = buf;
+	int channels;
+	int sampleindex;
+
+	//CLog::Log(LOGDEBUG, "data_size 0x%x", pkt->data_size);
+
+	if(pkt->samplerate == 96000)
+		sampleindex = 0;
+	else if(pkt->samplerate == 88200)
+		sampleindex = 1;
+	else if(pkt->samplerate == 64000)
+		sampleindex = 2;
+	else if(pkt->samplerate == 48000)
+		sampleindex = 3;
+	else if(pkt->samplerate == 44100)
+		sampleindex = 4;
+	else if(pkt->samplerate == 32000)
+		sampleindex = 5;
+	else if(pkt->samplerate == 24000)
+		sampleindex = 6;
+	else if(pkt->samplerate == 22050)
+		sampleindex = 7;
+	else if(pkt->samplerate == 16000)
+		sampleindex = 8;
+	else if(pkt->samplerate == 12000)
+		sampleindex = 9;
+	else if(pkt->samplerate == 11015)
+		sampleindex = 10;
+	else if(pkt->samplerate == 8000)
+		sampleindex = 11;
+	else if(pkt->samplerate == 7350)
+		sampleindex = 12;
+	else
+		sampleindex = 3;
+
+	channels = pkt->nchannels;
+
+	PacketLength    = pkt->data_size + AAC_HEADER_LENGTH;
+
+	if(size >= 2)
+	{
+		/* extradata
+		13 10 56 e5 9d 48 00 (anderen cops)
+			object_type: 00010 2 = LC
+			sample_rate: 011 0 6 = 24000
+			chan_config: 0010 2 = Stereo
+			000 0
+			1010110 111 = 0x2b7
+			00101 = SBR
+			1
+			0011 = 48000
+			101 01001000 = 0x548
+			ps = 0
+			0000000
+		*/
+
+		p = extradata;
+
+		unsigned int object_type = 2; // LC
+
+		object_type = extradata[0] >> 3;
+		sampleindex = ((extradata[0] & 0x7) << 1) + (extradata[1] >> 7);
+		channels = (extradata[1] >> 3) && 0xf;
+
+		object_type -= 1; // Cause of ADTS
+
+		ExtraData[0] = 0xFF;
+		ExtraData[1] = 0xF1;
+		ExtraData[2] = ((object_type & 0x03) << 6)  | (sampleindex << 2) | ((channels >> 2) & 0x01);
+		ExtraData[3] = (channels & 0x03) << 6;
+		ExtraData[4] = 0x00;
+		ExtraData[5] = 0x1F;
+		ExtraData[6] = 0xFC;
+
+	}
+	else
+	{
+		p = DefaultAACHeader;
+		memcpy (ExtraData, p, AAC_HEADER_LENGTH);
+
+		ExtraData[2] = 0;
+		ExtraData[2] = (0x01 << 6); // (Profile & 0x03) << 6)
+		ExtraData[2] |= (sampleindex << 2); // (SampleIndex << 2)
+		ExtraData[2] |= ((channels >> 2) & 0x01); // ((Channels >> 2) & 0x01)
+
+		ExtraData[3] = 0;
+		ExtraData[3] |= ((channels & 0x03) << 6); // (Channels & 0x03) << 6
+	}
+
+	ExtraData[3]       |= (PacketLength >> 12) & 0x3;
+	ExtraData[4]        = (PacketLength >> 3) & 0xff;
+	ExtraData[5]       |= (PacketLength << 5) & 0xe0;
+#if 1
+	HeaderLength = (sizeof(ExtraData) + 7) & ~7;
+	pkt->hdr->size = sizeof(ExtraData);
+
+	pkt->hdr->data = (char *)malloc(HeaderLength);
+	PacketStart = (unsigned char *)pkt->hdr->data;
+
+	memcpy (PacketStart, ExtraData, sizeof(ExtraData));
+#else
+	HeaderLength = InsertPesHeader (PesHeader, PacketLength, AAC_AUDIO_PES_START_CODE, pkt->avpts, 0);
+	pkt->hdr->size = HeaderLength + sizeof(ExtraData);
+
+	pkt->hdr->data = (char *)malloc(pkt->hdr->size);
+	PacketStart = (unsigned char *)pkt->hdr->data;
+
+	memcpy (PacketStart, PesHeader, HeaderLength);
+	memcpy (PacketStart + HeaderLength, ExtraData, sizeof(ExtraData));
+#endif
+
+	return PLAYER_SUCCESS;
+}
+
+#if 0 //Spitzbube
+
+static int aac_write_header(hisi_private_t *para, hisi_packet_t *pkt)
+{
+    int ret = -1;
+
+    if (pkt->hdr == NULL) {
+        pkt->hdr = (hdr_buf_t*)malloc(sizeof(hdr_buf_t));
+        pkt->hdr->data = (char *)malloc(8);
+        if (!pkt->hdr->data) {
+            CLog::Log(LOGDEBUG, "[pre_header_feeding] NOMEM!");
+            return PLAYER_NOMEM;
+        }
+    }
+
+    ret = aac_add_header(para->extradata, para->extrasize, pkt);
+    if (ret == PLAYER_SUCCESS) {
+        pkt->newflag = 1;
+        ret = write_a_packet(para, pkt);
+    }
+
+    if (pkt->hdr) {
+        if (pkt->hdr->data) {
+            free(pkt->hdr->data);
+            pkt->hdr->data = NULL;
+        }
+        free(pkt->hdr);
+        pkt->hdr = NULL;
+    }
+    //CLog::Log(LOGDEBUG, "aac_write_header 2");
+    return ret;
+}
+
+static int mp3_add_header(unsigned char *buf, int extrasize, hisi_packet_t *pkt)
+{
+    CLog::Log(LOGDEBUG, "mp3_add_header");
+#define STUFF_BYTES_LENGTH     (256)
+    int size;
+    unsigned char packet_wrapper[] = {
+        0x00, 0x00, 0x01, 0xe0,
+        0x00, 0x00,                                /* pes packet length */
+        0x81, 0xc0, 0x0d,
+        0x20, 0x00, 0x00, 0x00, 0x00, /* PTS */
+        0x1f, 0xff, 0xff, 0xff, 0xff, /* DTS */
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff
+    };
+
+    size = sizeof(packet_wrapper);
+    size += extrasize;
+    size += STUFF_BYTES_LENGTH;
+    pkt->hdr->size = size;
+
+    pkt->hdr->data = (char *)malloc(pkt->hdr->size);
+
+    size = extrasize + sizeof(packet_wrapper);
+    packet_wrapper[4] = size >> 8 ;
+    packet_wrapper[5] = size & 0xff ;
+    memcpy(pkt->hdr->data, packet_wrapper, sizeof(packet_wrapper));
+    size = sizeof(packet_wrapper);
+    memcpy(pkt->hdr->data + size, buf, extrasize);
+    size += extrasize;
+    memset(pkt->hdr->data + size, 0xff, STUFF_BYTES_LENGTH);
+
+    return PLAYER_SUCCESS;
+}
+#endif //Spitzbube
+
+static int pre_a_header_feeding(hisi_private_t *para, hisi_packet_t *pkt)
+{
+    return PLAYER_SUCCESS;
+}
+
+#if 0 //Spitzbube
+static int set_a_header_info(hisi_private_t *para)
+{
+  hisi_packet_t *pkt = &para->hisi_pkt;
+
+  if (pkt->newflag)
+  {
+    if (pkt->hdr)
+      pkt->hdr->size = 0;
+
+    if (para->audio_codec_id == HA_AUDIO_ID_AAC)
+    {
+      aac_write_header(para, pkt);
+    }
+  }
+  return PLAYER_SUCCESS;
+}
+
+#endif //Spitzbube
+
+CHisiAudioCodec::CHisiAudioCodec() : CThread("CHisiAudioCodec")
+{
+  hisi_private = new hisi_private_t;
+  memset(hisi_private, 0, sizeof(hisi_private_t));
+
+  m_dll_sample = new DllLibHiSample;
+  m_dll_comm = new DllLibHiComm;
+  m_dll_mpi = new DllLibHiMpi;
+
+  m_dll_sample->Load();
+  m_dll_comm->Load();
+  m_dll_mpi->Load();
+
+  hisi_private->m_dll_sample = m_dll_sample;
+  hisi_private->m_dll_comm = m_dll_comm;
+  hisi_private->m_dll_mpi = m_dll_mpi;
+  hisi_private->m_hAvplay = m_hAvplay;
+}
+
+
+CHisiAudioCodec::~CHisiAudioCodec()
+{
+  StopThread();
+
+  delete hisi_private;
+  hisi_private = NULL;
+
+  delete m_dll_sample, m_dll_sample = NULL;
+  delete m_dll_comm, m_dll_comm = NULL;
+  delete m_dll_mpi, m_dll_mpi = NULL;
+}
+
+static HI_S32 HandleEvent(HI_HANDLE hAvplay, HI_UNF_AVPLAY_EVENT_E enEvent, HI_U32 u32Para)
+{
+  CLog::Log(LOGDEBUG, "CHisiAudioCodec::HandleEvent: enEvent=%d", enEvent);
+
+  if (enEvent == HI_UNF_AVPLAY_EVENT_NEW_AUD_FRAME)
+  {
+	  HI_UNF_AO_FRAMEINFO_S* p = (HI_UNF_AO_FRAMEINFO_S*) u32Para;
+
+	  CLog::Log(LOGDEBUG, "CHisiAudioCodec::HandleEvent: u32FrameIndex=%d, u32PtsMs=%d",
+			  p->u32FrameIndex, p->u32PtsMs);
+
+#if 0
+	    /** s32BitPerSample: (PCM) Data depth, and format of storing the output data
+	          If the data depth is 16 bits, 16-bit word memory is used.
+	          If the data depth is greater than 16 bits, 32-bit word memory is used, and data is stored as left-aligned data. That is, the valid data is at upper bits.
+	     */
+	    /**CNcomment: s32BitPerSample: (PCM) Êý¾ÝÎ»¿íÉèÖÃ. Êä³ö´æ·Å¸ñÊ½
+	          µÈÓÚ16bit:   Õ¼ÓÃ16bit wordÄÚ´æ
+	          ´óÓÚ16bit:   Õ¼ÓÃ32bit wordÄÚ´æ, Êý¾Ý×ó¶ÔÆë·½Ê½´æ·Å(ÓÐÐ§Êý¾ÝÔÚ¸ßÎ»)
+	     */
+	    HI_S32  s32BitPerSample;       /**<Data depth*/ /**<CNcomment: Êý¾ÝÎ»¿í*/
+	    HI_BOOL bInterleaved;          /**<Whether the data is interleaved*/ /**<CNcomment: Êý¾ÝÊÇ·ñ½»Ö¯*/
+	    HI_U32  u32SampleRate;         /**<Sampling rate*/ /**<CNcomment: ²ÉÑùÂÊ*/
+	    HI_U32  u32Channels;           /**<Number of channels*/ /**<CNcomment: Í¨µÀÊýÁ¿*/
+	    HI_U32  u32PtsMs;              /**<Presentation time stamp (PTS)*/ /**<CNcomment: Ê±¼ä´Á*/
+	    HI_S32 *ps32PcmBuffer;         /**<Pointer to the buffer for storing the pulse code modulation (PCM) data*/ /**<CNcomment: PCMÊý¾Ý»º³åÖ¸Õë*/
+	    HI_S32 *ps32BitsBuffer;        /**<Pointer to the buffer for storing the stream data*/ /**<CNcomment: ÂëÁ÷Êý¾Ý»º³åÖ¸Õë*/
+	    HI_U32  u32PcmSamplesPerFrame; /**<Number of sampling points of the PCM data*/ /**<CNcomment: PCMÊý¾Ý²ÉÑùµãÊýÁ¿*/
+	    HI_U32  u32BitsBytesPerFrame;  /**<IEC61937 data size*/ /**<CNcomment: IEC61937Êý¾Ý³¤¶È*/
+	    HI_U32  u32FrameIndex;         /**<Frame ID*/ /**<CNcomment: Ö¡ÐòºÅ */
+		HI_U32  u32IEC61937DataType;      /**<IEC61937 Data Type*/ /**<CNcomment: IEC61937Êý¾ÝÀàÐÍ±êÊ¶£¬µÍ8bitÎªIECÊý¾ÝÀàÐÍ */
+#endif
+  }
+
+  return HI_SUCCESS;
+}
+
+bool CHisiAudioCodec::OpenDecoder(CDVDStreamInfo &hints)
+{
+  HI_S32 Ret;
+  //HI_UNF_AVPLAY_ATTR_S AvplayAttr;
+  //HI_UNF_SYNC_ATTR_S AvSyncAttr;
+#if 0 //Spitzbube
+  HI_UNF_ACODEC_ATTR_S stAdecAttr;
+  HI_UNF_AVPLAY_STOP_OPT_S Stop;
+#endif //Spitzbube
+  HI_HA_DECODEMODE_E enAudioDecMode = HD_DEC_MODE_RAWPCM;
+  HI_S32 s32DtsDtsCoreOnly = 0;
+
+  CLog::Log(LOGDEBUG, "CHisiAudioCodec::OpenDecoder");
+  CLog::Log(LOGDEBUG, "CHisiAudioCodec::channels(%d), samplerate(%d), bitspersample(%d)", hints.channels, hints.samplerate, hints.bitspersample);
+
+  g_m_hasync = 0;
+
+  m_volume = g_application.GetVolume();//(int)g_settings.m_fVolumeLevel;
+  m_mute = g_application.IsMuted();//(int)g_settings.m_bMute;
+  CLog::Log(LOGDEBUG, "CHisiAudioCodec::m_volume(%d), m_mute(%d)", m_volume, m_mute);
+
+  m_1st_pts = 0;
+  m_cur_pts = 0;
+  m_cur_audcnt = 0;
+  m_old_audcnt = 0;
+  m_speed = DVD_PLAYSPEED_NORMAL;
+  m_opened = false;
+  m_AdecType = 0;
+
+  switch(hints.codec)
+  {
+  case CODEC_ID_EAC3:
+  case CODEC_ID_TRUEHD:
+  case CODEC_ID_AC3:
+  case CODEC_ID_DTS:
+      CLog::Log(LOGDEBUG, "CHisiAudioCodec::OpenDecoder : HA_AUDIO_ID_DOLBY_PLUS");
+      m_AdecType = HA_AUDIO_ID_DOLBY_PLUS;
+      //m_AdecType = HA_AUDIO_ID_DTSHD;
+      break;
+  case CODEC_ID_MP2:
+      CLog::Log(LOGDEBUG, "CHisiAudioCodec::OpenDecoder : HA_AUDIO_ID_MP2");
+      m_AdecType = HA_AUDIO_ID_MP2;
+      break;
+  case CODEC_ID_MP3:
+      CLog::Log(LOGDEBUG, "CHisiAudioCodec::OpenDecoder : HA_AUDIO_ID_MP3");
+      m_AdecType = HA_AUDIO_ID_MP3;
+      break;
+  case CODEC_ID_PCM_S32LE:
+  case CODEC_ID_PCM_S32BE:
+  case CODEC_ID_PCM_U32LE:
+  case CODEC_ID_PCM_U32BE:
+  case CODEC_ID_PCM_S24LE:
+  case CODEC_ID_PCM_S24BE:
+  case CODEC_ID_PCM_U24LE:
+  case CODEC_ID_PCM_U24BE:
+  case CODEC_ID_PCM_S24DAUD:
+  case CODEC_ID_PCM_S16LE:
+  case CODEC_ID_PCM_S16BE:
+  case CODEC_ID_PCM_U16LE:
+  case CODEC_ID_PCM_U16BE:
+  case CODEC_ID_PCM_S8:
+  case CODEC_ID_PCM_U8:
+  case CODEC_ID_PCM_ALAW:
+  case CODEC_ID_PCM_MULAW:
+      CLog::Log(LOGDEBUG, "CHisiAudioCodec::OpenDecoder : HA_AUDIO_ID_PCM");
+      m_AdecType = HA_AUDIO_ID_PCM;
+      break;
+  case CODEC_ID_AAC:
+      CLog::Log(LOGDEBUG, "CHisiAudioCodec::OpenDecoder : HA_AUDIO_ID_AAC");
+      m_AdecType = HA_AUDIO_ID_AAC;
+      break;
+    default:
+      CLog::Log(LOGDEBUG, "Codec not supported codec = 0x%x", hints.codec);
+      return false;
+      break;
+  }
+
+  CLog::Log(LOGDEBUG, "CHisiAudioCodec::OpenDecoder : m_AdecType(%d)", m_AdecType);
+
+  if(!g_m_hAvplay)
+  {
+    CLog::Log(LOGDEBUG, "CHisiAudioCodec::OpenDecoder : g_m_hAvplay NULL");
+    return false;
+  }
+
+  m_hAvplay = g_m_hAvplay;
+
+#if 0
+  m_dll_comm->HI_SYS_Init();
+  m_dll_comm->HI_SYS_PreAV(NULL);
+  Ret = m_dll_mpi->HI_UNF_AVPLAY_Init();
+  if (Ret != HI_SUCCESS)
+  {
+    CLog::Log(LOGDEBUG, "call HI_UNF_AVPLAY_Init failed. ret=0x%x", Ret);
+    goto SND_DEINIT;
+  }
+#endif
+#if 1
+  Ret = m_dll_sample->HIADP_Snd_Init();
+  if (Ret != HI_SUCCESS)
+  {
+    CLog::Log(LOGDEBUG, "call SndInit failed.\n");
+    goto SND_DEINIT;
+  }
+
+  Ret = m_dll_sample->HIADP_AVPlay_RegADecLib();
+  if (Ret != HI_SUCCESS)
+  {
+    CLog::Log(LOGDEBUG, "call HI_UNF_AVPLAY_RegisterAcodecLib failed.\n");
+    goto SND_DEINIT;
+  }
+#endif
+
+#if 0 //Spitzbube
+  if(m_AdecType == HA_AUDIO_ID_MP3)
+  {
+    Ret = m_dll_mpi->HI_UNF_AVPLAY_GetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_ADEC, &stAdecAttr);
+
+    stAdecAttr.enType = HA_AUDIO_ID_MP3;
+    stAdecAttr.stDecodeParam.enDecMode = HD_DEC_MODE_RAWPCM;
+    HA_MP3_DecGetDefalutOpenParam(&(stAdecAttr.stDecodeParam));
+
+    /* set AVPLAY's audio attribute */
+
+    Ret = m_dll_mpi->HI_UNF_AVPLAY_SetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_ADEC, &stAdecAttr);
+  }
+#endif //Spitzbube
+
+  Ret = m_dll_mpi->HI_UNF_AVPLAY_ChnOpen(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD, HI_NULL);
+  if (Ret != HI_SUCCESS)
+  {
+    CLog::Log(LOGDEBUG, "call HI_UNF_AVPLAY_ChnOpen failed. ret=0x%x", Ret);
+    goto AVPLAY_DESTROY;
+  }
+
+#if 0 //Spitzbube: old SDK
+  Ret =  m_dll_mpi->HI_UNF_SND_Attach(HI_UNF_SND_0, m_hAvplay, HI_UNF_SND_MIX_TYPE_MASTER, 100);
+  if (Ret != HI_SUCCESS)
+  {
+    CLog::Log(LOGDEBUG, "call HI_SND_Attach failed.\n");
+    goto ACHN_CLOSE;
+  }
+#else
+  HI_UNF_AUDIOTRACK_ATTR_S  stTrackAttr;
+  Ret = m_dll_mpi->HI_UNF_SND_GetDefaultTrackAttr(HI_UNF_SND_TRACK_TYPE_MASTER, &stTrackAttr);
+  if (Ret != HI_SUCCESS)
+  {
+    CLog::Log(LOGDEBUG, "call HI_UNF_SND_GetDefaultTrackAttr failed.\n");
+    goto ACHN_CLOSE;
+  }
+
+  Ret = m_dll_mpi->HI_UNF_SND_CreateTrack(HI_UNF_SND_0,&stTrackAttr, &m_hTrack);
+  if (Ret != HI_SUCCESS)
+  {
+	CLog::Log(LOGDEBUG, "call HI_UNF_SND_CreateTrack failed.\n");
+    goto ACHN_CLOSE;
+  }
+
+  Ret = m_dll_mpi->HI_UNF_SND_Attach(m_hTrack, m_hAvplay);
+  if (Ret != HI_SUCCESS)
+  {
+	CLog::Log(LOGDEBUG, "call HI_UNF_SND_Attach failed.\n");
+    goto TRACK_DESTROY;
+  }
+#endif //Spitzbube: new SDK
+
+  Ret = m_dll_sample->HIADP_AVPlay_SetAdecAttr(m_hAvplay, m_AdecType, enAudioDecMode, s32DtsDtsCoreOnly);
+  if (Ret != HI_SUCCESS)
+  {
+    CLog::Log(LOGDEBUG, "call HI_UNF_AVPLAY_SetAttr failed.\n");
+    goto SND_DETACH;
+  }
+
+  Ret = m_dll_mpi->HI_UNF_AVPLAY_Start(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD, HI_NULL);
+  if (Ret != HI_SUCCESS)
+  {
+    CLog::Log(LOGDEBUG, "call HI_UNF_AVPLAY_Start failed.\n");
+  }
+  m_opened = true;
+
+#if 0 //Spitzbube: old SDK
+  Ret = m_dll_mpi->HI_UNF_SND_SetSpdifPassThrough(HI_UNF_SND_0, HI_FALSE/*HI_TRUE*/);
+  Ret = m_dll_mpi->HI_UNF_SND_SetHdmiPassThrough(HI_UNF_SND_0, HI_FALSE/*HI_TRUE*/);
+#else
+  m_dll_mpi->HI_UNF_SND_SetSpdifMode(HI_UNF_SND_0, HI_UNF_SND_OUTPUTPORT_SPDIF0, HI_UNF_SND_SPDIF_MODE_RAW); //HI_UNF_SND_SPDIF_MODE_LPCM);
+  m_dll_mpi->HI_UNF_SND_SetHdmiMode(HI_UNF_SND_0, HI_UNF_SND_OUTPUTPORT_HDMI0, HI_UNF_SND_HDMI_MODE_RAW); //HI_UNF_SND_HDMI_MODE_LPCM);
+#endif
+
+  // handle hints.
+  hisi_private->audio_codec_id   = m_AdecType;
+
+#if 0
+#if 1
+  HI_U32 volume;
+  if (m_dll_mpi->HI_UNF_SND_GetVolume(HI_UNF_SND_0, &volume) == 0 && volume != 100)
+    m_dll_mpi->HI_UNF_SND_SetVolume(HI_UNF_SND_0, 100);
+#else
+  float volume;
+  if (m_dll->codec_get_volume(NULL, &volume) == 0 && volume != 1.0)
+    m_dll->codec_set_volume(NULL, 1.0);
+#endif
+#endif
+
+  if(hints.extrasize > 0)
+  {
+    //CLog::Log(LOGDEBUG, "CHisiAudioCodec : extrasize %d", hints.extrasize);
+    hisi_private->extrasize       = hints.extrasize;
+    hisi_private->extradata       = (uint8_t*)malloc(hints.extrasize);
+    memcpy(hisi_private->extradata, hints.extradata, hints.extrasize);
+
+    CLog::Log(LOGDEBUG, "extradata(%d) %02x %02x %02x %02x %02x %02x %02x",
+	  hisi_private->extrasize, hisi_private->extradata[0], hisi_private->extradata[1], hisi_private->extradata[2],
+	  hisi_private->extradata[3], hisi_private->extradata[4], hisi_private->extradata[5], hisi_private->extradata[6]);
+  }
+
+  hisi_packet_init(&hisi_private->hisi_pkt);
+  hisi_private->hisi_pkt.nchannels = hints.channels;
+  hisi_private->hisi_pkt.samplerate = hints.samplerate;
+  // default stream type
+  hisi_private->stream_type      = HISI_STREAM_ES;
+
+  hisi_private->m_hAvplay = m_hAvplay;
+
+  hisi_private->m_preloading_done = 0;
+  /*
+  pre_header_feeding(hisi_private, &hisi_private->hisi_pkt);
+  */
+
+  m_dll_mpi->HI_UNF_AVPLAY_RegisterEvent(m_hAvplay, HI_UNF_AVPLAY_EVENT_NEW_AUD_FRAME, HandleEvent);
+  m_dll_mpi->HI_UNF_AVPLAY_RegisterEvent(m_hAvplay, HI_UNF_AVPLAY_EVENT_AUD_BUF_STATE, HandleEvent);
+
+  Create();
+
+  return true;
+
+#if 0 //Spitzbube
+//AVPLAY_VSTOP:
+  Stop.enMode = HI_UNF_AVPLAY_STOP_MODE_BLACK;
+  Stop.u32TimeoutMs = 0;
+  m_dll_mpi->HI_UNF_AVPLAY_Stop(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD, &Stop);
+#endif //Spitzbube
+
+SND_DETACH:
+#if 0 //Spitzbube: old SDK
+  m_dll_mpi->HI_UNF_SND_Detach(HI_UNF_SND_0, m_hAvplay);
+#else
+  m_dll_mpi->HI_UNF_SND_Detach(m_hTrack, m_hAvplay);
+
+TRACK_DESTROY:
+  m_dll_mpi->HI_UNF_SND_DestroyTrack(m_hTrack);
+#endif
+
+ACHN_CLOSE:
+  m_dll_mpi->HI_UNF_AVPLAY_ChnClose(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD);
+
+AVPLAY_DESTROY:
+  //m_dll_mpi->HI_UNF_AVPLAY_Destroy(m_hAvplay);
+
+//AVPLAY_DEINIT:
+  //m_dll_mpi->HI_UNF_AVPLAY_DeInit();
+
+SND_DEINIT:
+//DISP_DEINIT:
+//SYS_DEINIT:
+  //m_dll_comm->HI_SYS_DeInit();
+
+  return false;
+}
+
+void CHisiAudioCodec::CloseDecoder()
+{
+  HI_UNF_AVPLAY_STOP_OPT_S Stop;
+
+  CLog::Log(LOGDEBUG, "CHisiAudioCodec::CloseDecoder");
+  StopThread();
+
+  m_dll_mpi->HI_UNF_AVPLAY_UnRegisterEvent(m_hAvplay, HI_UNF_AVPLAY_EVENT_NEW_AUD_FRAME);
+  m_dll_mpi->HI_UNF_AVPLAY_UnRegisterEvent(m_hAvplay, HI_UNF_AVPLAY_EVENT_AUD_BUF_STATE);
+
+  hisi_packet_release(&hisi_private->hisi_pkt);
+  free(hisi_private->extradata);
+  hisi_private->extradata = NULL;
+  m_opened = false;
+
+  Stop.enMode = HI_UNF_AVPLAY_STOP_MODE_BLACK;
+  Stop.u32TimeoutMs = 0;
+  m_dll_mpi->HI_UNF_AVPLAY_Stop(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD, &Stop);
+#if 0 //Spitzbube: old SDK
+  m_dll_mpi->HI_UNF_SND_Detach(HI_UNF_SND_0, m_hAvplay);
+#else
+  m_dll_mpi->HI_UNF_SND_Detach(m_hTrack, m_hAvplay);
+  m_dll_mpi->HI_UNF_SND_DestroyTrack(m_hTrack);
+#endif
+  m_dll_mpi->HI_UNF_AVPLAY_ChnClose(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD);
+
+#if 0
+  m_dll_mpi->HI_UNF_AVPLAY_Destroy(m_hAvplay);
+
+  m_dll_mpi->HI_UNF_AVPLAY_DeInit();
+
+  m_dll_comm->HI_SYS_DeInit();
+#endif
+  m_dll_sample->Unload();
+  m_dll_comm->Unload();
+  m_dll_mpi->Unload();
+
+  hisi_private->m_dll_sample = m_dll_sample = NULL;
+  hisi_private->m_dll_comm = m_dll_comm = NULL;
+  hisi_private->m_dll_mpi = m_dll_mpi = NULL;
+
+  hisi_private->m_hAvplay = m_hAvplay = 0;
+}
+
+#if 0 //Spitzbube
+
+void CHisiAudioCodec::Reset()
+{
+  CLog::Log(LOGDEBUG, "CHisiAudioCodec::Reset");
+
+  if (!m_opened)
+    return;
+#if 0
+  hisi_packet_release(&hisi_private->hisi_pkt);
+  hisi_packet_init(&hisi_private->hisi_pkt);
+#endif
+  if(m_speed != DVD_PLAYSPEED_NORMAL)
+  {
+    CLog::Log(LOGDEBUG, "CHisiAudioCodec::Reset - Audio Reset");
+    m_dll_mpi->HI_UNF_AVPLAY_Start(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD, HI_NULL);
+
+    g_m_hasync = 0;
+
+    m_1st_pts = 0;
+    m_cur_pts = 0;
+    m_cur_audcnt = 0;
+    m_old_audcnt = 0;
+
+    hisi_private->m_preloading_done = 0;
+  }
+}
+
+#endif //Spitzbube
+
+int CHisiAudioCodec::Decode(uint8_t *pData, size_t size, double dts)
+{
+  CLog::Log(LOGDEBUG, "CHisiAudioCodec::Decode >> size=%d, dts=%f", size, dts);
+
+  if (!m_opened)
+    return -1;
+
+#if 1
+  HI_S32 s32Res;
+
+  if (pData)
+  {
+    HI_UNF_STREAM_BUF_S StreamBuf;
+    HI_U32 u32TimeOutMs = 0;
+    HI_U32 u32PtsMs = 0xFFFFFFFF;
+#if 0
+    if (/*(double)AV_NOPTS_VALUE*/DVD_NOPTS_VALUE != dts)
+      u32PtsMs = (HI_U32)(dts/PTS_FREQ_MS);
+#endif
+
+    int Retry;
+    for (Retry = 0; Retry < 10; Retry++)
+    {
+      s32Res = m_dll_mpi->HI_UNF_AVPLAY_GetBuf(m_hAvplay, HI_UNF_AVPLAY_BUF_ID_ES_AUD,
+    		  size, &StreamBuf, u32TimeOutMs);
+      if (HI_SUCCESS == s32Res)
+      {
+        memcpy(StreamBuf.pu8Data, pData, size);
+
+        s32Res = m_dll_mpi->HI_UNF_AVPLAY_PutBuf(m_hAvplay, HI_UNF_AVPLAY_BUF_ID_ES_AUD,
+        		size, u32PtsMs);
+        if (HI_SUCCESS == s32Res)
+        {
+        }
+        else
+        {
+          CLog::Log(LOGERROR, "CHisiAudioCodec::Decode, HI_UNF_AVPLAY_PutBuf failed(0x%x)", s32Res);
+        }
+        break;
+      }
+      else
+      {
+    	CLog::Log(LOGERROR, "CHisiAudioCodec::Decode, HI_UNF_AVPLAY_GetBuf failed(0x%x)", s32Res);
+        usleep(RW_WAIT_TIME);
+      }
+    } //for (Retry = 0; Retry < 10; Retry++)
+  } //if (pData)
+
+  HI_UNF_AVPLAY_STATUS_INFO_S stStatusInfo;
+  s32Res = m_dll_mpi->HI_UNF_AVPLAY_GetStatusInfo(m_hAvplay, &stStatusInfo);
+  if (s32Res == HI_SUCCESS)
+  {
+	CLog::Log(LOGERROR, "CHisiAudioCodec::Decode, stStatusInfo.stBufStatus.u32BufSize=%d, u32BufRptr=%d, u32BufWptr=%d, u32UsedSize=%d",
+			stStatusInfo.stBufStatus[HI_UNF_AVPLAY_BUF_ID_ES_AUD].u32BufSize,
+			stStatusInfo.stBufStatus[HI_UNF_AVPLAY_BUF_ID_ES_AUD].u32BufRptr,
+			stStatusInfo.stBufStatus[HI_UNF_AVPLAY_BUF_ID_ES_AUD].u32BufWptr,
+			stStatusInfo.stBufStatus[HI_UNF_AVPLAY_BUF_ID_ES_AUD].u32UsedSize);
+	CLog::Log(LOGERROR, "CHisiAudioCodec::Decode, stStatusInfo.stBufStatus.u32FrameBufTime=%d, u32FrameBufNum=%d, bEndOfStream=%d",
+			stStatusInfo.stBufStatus[HI_UNF_AVPLAY_BUF_ID_ES_AUD].u32FrameBufTime,
+			stStatusInfo.stBufStatus[HI_UNF_AVPLAY_BUF_ID_ES_AUD].u32FrameBufNum,
+			stStatusInfo.stBufStatus[HI_UNF_AVPLAY_BUF_ID_ES_AUD].bEndOfStream);
+  }
+
+
+#else
+  if(hisi_private->m_preloading_done == 0)
+  {
+    pre_a_header_feeding(hisi_private, &hisi_private->hisi_pkt);
+    hisi_private->m_preloading_done = 1;
+  }
+
+  if (pData)
+  {
+    hisi_private->hisi_pkt.data       = pData;
+    hisi_private->hisi_pkt.data_size  = size;
+    hisi_private->hisi_pkt.newflag    = 1;
+    hisi_private->hisi_pkt.isvalid    = 1;
+    hisi_private->hisi_pkt.avduration = 0;
+
+    hisi_private->hisi_pkt.avpts = AV_NOPTS_VALUE;
+#if 0 //Spitzbube: TODO
+    if (dts && dts != DVD_NOPTS_VALUE)
+    {
+      double pts_diff= 0.0;
+      if(m_cur_pts > 0 && m_cur_pts < 40000000000.0 && (dts -m_cur_pts) > 800000)
+      {
+	    double timeout = dts -m_cur_pts - 550000;
+
+	    timeout /= PTS_FREQ;
+	    timeout *= DVD_TIME_BASE;
+
+         if(timeout < 10000000/*5000000*/)
+         {
+	       CLog::Log(LOGDEBUG, "CDVDPlayerAudio - WAIT DECODE(%f)(%f)(%f)", dts, m_cur_pts, timeout);
+
+           timeout += CDVDClock::GetAbsoluteClock();
+
+           while(!m_bStop && CDVDClock::GetAbsoluteClock() < timeout)
+             Sleep(1);
+         }
+         else
+           m_cur_pts = dts;
+	  }
+
+	  pts_diff = g_m_hasync - g_m_hvsync;
+
+       //if (fabs(pts_diff/PTS_FREQ) > 0.5 && fabs(pts_diff/PTS_FREQ) < 10.0 /*5.0*/ && g_m_hasync > 0 && g_m_hvsync > 0)
+      if (fabs(pts_diff/PTS_FREQ) > 0.2 && fabs(pts_diff/PTS_FREQ) < 20.0 /*5.0*/ && g_m_hasync > 0 && g_m_hvsync > 0)
+	  {
+		//CLog::Log(LOGDEBUG, "m_hints: ap(%f)(%f)(%f)", pts_diff, g_m_hvsync, g_m_hasync);
+		if(pts_diff > 0)
+		{
+	         double timeout = pts_diff;
+
+	         timeout /= PTS_FREQ;
+                //if(timeout > 1.0)
+                	//timeout = 1.0;
+                if(timeout > 2.0)
+                   timeout = 2.0;
+	         timeout *= DVD_TIME_BASE;
+
+	         CLog::Log(LOGDEBUG, "CDVDPlayerAudio - WAIT SYNC(%f)(%f)(%f)", dts, m_cur_pts, timeout);
+
+	         timeout += CDVDClock::GetAbsoluteClock();
+
+	         while(!m_bStop && CDVDClock::GetAbsoluteClock() < timeout)
+	          Sleep(1);
+		}
+		else
+		{
+		  g_m_hasync = g_m_hvsync;
+		  m_cur_pts = dts;
+		  return size;
+		}
+	  }
+
+	  hisi_private->hisi_pkt.avpts = dts;
+    } //if (dts && dts != DVD_NOPTS_VALUE)
+#endif //Spitzbube
+
+    hisi_private->hisi_pkt.avdts = AV_NOPTS_VALUE;
+
+    //CLog::Log(LOGDEBUG, "m_hints: video dts(%f), pts(%f)", g_m_hvdts, g_m_hvpts);
+    //CLog::Log(LOGDEBUG, "m_hints: audio dts(%f), pts(%f)", g_m_hadts, g_m_hapts);
+    /*
+    if ((int64_t)INT64_0 != hisi_private->hisi_pkt.avpts)
+      CLog::Log(LOGDEBUG, "CHisiAudioCodec::Decode: pts(%f), avpts(%f)", pts, hisi_private->hisi_pkt.avpts);
+    else
+      CLog::Log(LOGDEBUG, "CHisiAudioCodec::Decode: dts(%f), avdts(%f)", dts, hisi_private->hisi_pkt.avdts);
+    */
+    //CLog::Log(LOGDEBUG, "CHisiAudioCodec::Decode: dts(%f), avdts(%f), avpts(%f)",
+    //  dts, hisi_private->hisi_pkt.avdts, hisi_private->hisi_pkt.avpts);
+
+    //CLog::Log(LOGDEBUG, "CHisiAudioCodec::Decode: dts(%f)", dts);
+	/**/
+
+    //set_a_header_info(hisi_private);
+    write_a_packet(hisi_private, &hisi_private->hisi_pkt);
+      /**/
+#if 0 //Spitzbube: TODO
+    // if we seek, then GetTimeSize is wrong as
+    // reports lastpts - cur_pts and hw decoder has
+    // not started outputing new pts values yet.
+    // so we grab the 1st pts sent into driver and
+    // use that to calc GetTimeSize.
+    if (m_1st_pts == 0)
+    {
+    	CLog::Log(LOGDEBUG, "audio lastpts: (%f)(%f)", hisi_private->hisi_pkt.lastpts, m_1st_pts);
+       m_1st_pts = hisi_private->hisi_pkt.lastpts;
+    }
+#endif //Spitzbube: TODO
+  } //if (pData)
+  else
+  	return size;
+
+#if 0 //Spitzbube: TODO
+  // keep hw buffered demux above 1 second
+  if (GetTimeSize() < 1.0)
+  {
+    	//CLog::Log(LOGDEBUG, "GetTimeSize: underflow (%f)(%f)", hisi_private->hisi_pkt.lastpts, m_cur_pts);
+  }
+
+  // wait until we get a new frame or 100ms,
+  //m_ready_event.WaitMSec(200);
+
+  Sleep(20);
+
+  // we must return VC_BUFFER or VC_PICTURE,
+  // default to VC_BUFFER.
+  if (m_old_audcnt != m_cur_audcnt)
+  {
+    m_old_audcnt = m_cur_audcnt;
+    // we got a new pict, try and keep hw buffered demux above 2 seconds.
+    // this, combined with the above 1 second check, keeps hw buffered demux between 1 and 2 seconds.
+    // we also check to make sure we keep from filling hw buffer.
+    //if (GetTimeSize() < 2.0 && GetDataSize() < m_abufsize/3)
+    //	CLog::Log(LOGDEBUG, "GetTimeSize: underflow (%f)(%f)", hisi_private->hisi_pkt.lastpts, m_cur_pts);
+  }
+#endif //Spitzbube: TODO
+
+#endif
+
+  return size;
+}
+
+void CHisiAudioCodec::SetSpeed(int speed)
+{
+  CLog::Log(LOGDEBUG, "CHisiAudioCodec::SetSpeed, speed(%d)", speed);
+
+  // update internal vars regardless
+  // of if we are open or not.
+  m_speed = speed;
+
+  if (!m_opened)
+    return;
+
+  switch(speed)
+  {
+    case DVD_PLAYSPEED_PAUSE:
+      CLog::Log(LOGDEBUG, "CHisiAudioCodec::SetSpeed, Audio Pause");
+      PauseResume(1);
+	  //m_dll_mpi->HI_UNF_VO_SetWindowEnable(m_hWin, HI_FALSE);
+      break;
+    case DVD_PLAYSPEED_NORMAL:
+      CLog::Log(LOGDEBUG, "CHisiAudioCodec::SetSpeed, Audio Resume");
+      PauseResume(2);
+	  //m_dll_mpi->HI_UNF_VO_SetWindowEnable(m_hWin, HI_TRUE);
+      break;
+    default:
+      HI_UNF_AVPLAY_STOP_OPT_S Stop;
+      Stop.enMode = HI_UNF_AVPLAY_STOP_MODE_BLACK;
+      Stop.u32TimeoutMs = 0;
+      CLog::Log(LOGDEBUG, "CHisiAudioCodec::SetSpeed, Audio Stop");
+      m_dll_mpi->HI_UNF_AVPLAY_Stop(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD, &Stop);
+      break;
+  }
+}
+
+#if 0 //Spitzbube
+
+int CHisiAudioCodec::GetDataSize()
+{
+  if (!m_opened)
+    return 0;
+  HI_UNF_AVPLAY_STATUS_INFO_S stStatusInfo;
+  struct buf_status abuf ={0};
+  if(m_dll_mpi->HI_UNF_AVPLAY_GetStatusInfo(m_hAvplay, &stStatusInfo) == HI_SUCCESS)
+  {
+  	m_abufsize = stStatusInfo.stBufStatus[HI_UNF_AVPLAY_BUF_ID_ES_AUD].u32BufSize;
+	abuf.size = stStatusInfo.stBufStatus[HI_UNF_AVPLAY_BUF_ID_ES_AUD].u32BufSize;
+	abuf.data_len = stStatusInfo.stBufStatus[HI_UNF_AVPLAY_BUF_ID_ES_AUD].u32UsedSize;
+  }
+  return abuf.data_len;
+}
+
+#endif //Spitzbube
+
+double CHisiAudioCodec::GetTimeSize()
+{
+#if 0 //Spitzbube: TODO
+  if (!m_opened)
+    return 0.0;
+  // if m_cur_pts is zero, hw decoder was not started yet
+  // so we use the pts of the 1st demux packet that was send
+  // to hw decoder to calc timesize.
+  if (m_cur_pts == 0 || fabs(m_cur_pts-m_1st_pts)/DVD_TIME_BASE> 100)
+  {
+    m_timesize = (double)(hisi_private->hisi_pkt.lastpts - m_1st_pts) / PTS_FREQ;
+//CLog::Log(LOGDEBUG, "GetTimeSize: lastpts(%f), m_1st_pts(%f), m_timesize(%f)", hisi_private->hisi_pkt.lastpts, m_1st_pts, m_timesize);
+  }
+  else
+  {
+    m_timesize = (double)(hisi_private->hisi_pkt.lastpts - m_cur_pts) / PTS_FREQ;
+//CLog::Log(LOGDEBUG, "GetTimeSize: lastpts(%f), m_cur_pts(%f), m_timesize(%f)", hisi_private->hisi_pkt.lastpts, m_cur_pts, m_timesize);
+  }
+  // lie to DVDPlayer, it is hardcoded to a max of 8 seconds,
+  // if you buffer more than 8 seconds, it goes nuts.
+  double timesize = m_timesize;
+  if (timesize < 0.0)
+    timesize = 0.0;
+  else if (timesize > 7.0)
+    timesize = 7.0;
+
+  return timesize;
+#endif //Spitzbube
+}
+
+void CHisiAudioCodec::Process()
+{
+  CLog::Log(LOGDEBUG, "CHisiAudioCodec::Process Started");
+
+  // bump our priority to be level with SoftAE
+#if 0 //Spitzbube: TODO
+  SetPriority(THREAD_PRIORITY_ABOVE_NORMAL);
+#endif
+
+  while (!m_bStop)
+  {
+#if 0 //Spitzbube: TODO
+    double pts_audio= 0.0;
+    double duration= 0.0;
+    double pts_diff= 0.0;
+
+    if (hisi_private->hisi_pkt.lastpts > 0)
+    {
+#if 0 //Spitzbube
+      if(m_volume != g_application.GetVolume())
+      {
+        m_volume = g_application.GetVolume();
+	    CLog::Log(LOGDEBUG, "HI_UNF_SND_SetVolume: m_volume(%d)", m_volume);
+        m_dll_mpi->HI_UNF_SND_SetVolume(HI_UNF_SND_0, (HI_U32)m_volume);
+      }
+      if(m_mute != g_application.IsMuted())//(int)g_settings.m_bMute)
+      {
+        m_mute = g_application.IsMuted();//(int)g_settings.m_bMute;
+        m_dll_mpi->HI_UNF_SND_SetMute(HI_UNF_SND_0, (HI_BOOL)m_mute);
+      }
+#endif //Spitzbube
+
+      if (g_application.m_pPlayer && g_application.m_pPlayer->IsPlaying())
+      {
+        //CLog::Log(LOGDEBUG, "CHisiAudioCodec::Process: IsPlaying");
+        /*
+        if (g_application.m_pPlayer->IsPaused())
+          PauseResume(1);
+        else
+          PauseResume(2);
+        */
+        Sleep(10);
+      }
+
+      //m_dll_mpi->HI_UNF_SND_SetMute(HI_UNF_SND_0, (HI_BOOL)g_settings.m_bMute);
+
+      HI_UNF_AVPLAY_STATUS_INFO_S stStatusInfo;
+      if(m_dll_mpi->HI_UNF_AVPLAY_GetStatusInfo(m_hAvplay, &stStatusInfo) == HI_SUCCESS)
+      {
+        pts_audio = stStatusInfo.stSyncStatus.u32LastAudPts;
+        pts_audio *= PTS_FREQ_MS;
+        //CLog::Log(LOGDEBUG, "CHisiAudioCodec::Process: pts_video(%lld), pts_video/PTS_FREQ(%f), duration(%f)",
+          //pts_video, (double)pts_video/PTS_FREQ, 1.0/((double)(pts_video - m_cur_pts)/PTS_FREQ));
+      }
+      else
+      {
+        CLog::Log(LOGDEBUG, "CHisiAudioCodec::Process: no pts_audio(%f)", m_cur_pts);
+        pts_audio = m_cur_pts + 1000;
+      }
+      //pts_video = get_pts_video();
+      if (pts_audio && m_cur_pts != pts_audio)
+      {
+        duration = (double)(pts_audio - m_cur_pts)/PTS_FREQ;
+
+        //CLog::Log(LOGDEBUG, "ppts(%f), pts_audio(%f), duration(%f)", GetPlayerPtsSeconds(), pts_audio, (double)(pts_audio - m_cur_pts)/PTS_FREQ);
+        // other threads look at these, do them first
+        m_cur_pts = pts_audio;
+        m_cur_audcnt++;
+        //m_ready_event.Set();
+
+        if(pts_audio < 40000000000.0)
+        {
+          double app_pts = GetPlayerPtsSeconds();
+          // add in audio delay/display latency contribution
+          double offset  = 0;
+          // correct video pts by user set delay and rendering delay
+          app_pts += offset;
+
+          g_m_hasync = m_cur_pts;
+
+#if 0 //Spitzbube: TODO
+          pts_diff = pts_audio/PTS_FREQ - app_pts;
+
+          if (fabs(pts_diff) > 0.2 && duration > 0)
+          {
+             //CLog::Log(LOGDEBUG, "CHisiAudioCodec::aoffset(%f)(%f)(%f)", pts_diff, pts_audio, app_pts);
+	         if(pts_diff > 0)
+               SetAudioPtsSeconds(pts_audio - 100*PTS_FREQ_MS);
+	         else
+               SetAudioPtsSeconds(pts_audio + 100*PTS_FREQ_MS);
+          }
+#endif
+      	}
+      }
+    }
+    else
+    {
+      Sleep(10);
+    }
+#else //Spitzbube: TODO
+    Sleep(100);
+#endif
+  } //while (!m_bStop)
+
+#if 0 //Spitzbube: TODO
+  SetPriority(THREAD_PRIORITY_NORMAL);
+#endif
+
+  CLog::Log(LOGDEBUG, "CHisiAudioCodec::Process Stopped");
+}
+
+void CHisiAudioCodec::PauseResume(int state)
+{
+  static int saved_state = -1;
+  if (saved_state == state)
+    return;
+
+  CLog::Log(LOGDEBUG, "CHisiAudioCodec::PauseResume: state(%d)", state);
+
+  saved_state = state;
+  if (saved_state == 1)
+    m_dll_mpi->HI_UNF_AVPLAY_Pause(m_hAvplay, NULL);
+  else
+    m_dll_mpi->HI_UNF_AVPLAY_Resume(m_hAvplay, NULL);
+}
+
+double CHisiAudioCodec::GetPlayerPtsSeconds()
+{
+#if 0 //Spitzbube: TODO
+  double clock_pts = 0.0;
+#if 1
+  extern CDVDClock* g_m_hClock;
+  CDVDClock *playerclock = g_m_hClock;
+  if (playerclock)
+    clock_pts = playerclock->GetClock() / DVD_TIME_BASE;
+#else
+  HI_UNF_AVPLAY_STATUS_INFO_S stStatusInfo;
+  if(m_dll_mpi->HI_UNF_AVPLAY_GetStatusInfo(m_hAvplay, &stStatusInfo) == HI_SUCCESS)
+  {
+     clock_pts = stStatusInfo.stSyncStatus.u32LastAudPts / 1000;
+  }
+#endif
+  return clock_pts;
+#endif //Spitzbube: TODO
+}
+
+void CHisiAudioCodec::SetAudioPtsSeconds(const double pts)
+{
+#if 0 //Spitzbube: TODO
+  extern CDVDClock* g_m_hClock;
+  CDVDClock *playerclock = g_m_hClock;
+
+  if(playerclock)
+  playerclock->Discontinuity(pts);
+
+  //CLog::Log(LOGDEBUG, "CHisiAudioCodec::SetAudioPtsSeconds: pts(%f)", pts);
+  //set_pts_pcrscr((int64_t)(pts * PTS_FREQ));
+#endif
+}
+
diff -Naur kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Audio/HISIAudioCodec.h kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Audio/HISIAudioCodec.h
--- kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Audio/HISIAudioCodec.h	1970-01-01 01:00:00.000000000 +0100
+++ kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Audio/HISIAudioCodec.h	2016-04-10 19:50:43.287417267 +0200
@@ -0,0 +1,140 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2011 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "DVDAudioCodec.h"
+#include "cores/dvdplayer/DVDStreamInfo.h"
+#include "guilib/Geometry.h"
+#include "threads/Thread.h"
+#include "hi_unf_common.h"
+
+#define AUDIO_EXTRA_DATA_SIZE   (4096)
+
+typedef int CODEC_HANDLE;
+
+typedef enum {
+    STREAM_TYPE_UNKNOW,
+    STREAM_TYPE_ES_VIDEO,
+    STREAM_TYPE_ES_AUDIO,
+    STREAM_TYPE_ES_SUB,
+    STREAM_TYPE_PS,
+    STREAM_TYPE_TS,
+    STREAM_TYPE_RM,
+} stream_type_t;
+
+typedef struct {
+    unsigned int    format;  ///< video format, such as H264, MPEG2...
+    unsigned int    width;   ///< video source width
+    unsigned int    height;  ///< video source height
+    unsigned int    rate;    ///< video source frame duration
+    unsigned int    extra;   ///< extra data information of video stream
+    unsigned int    status;  ///< status of video stream
+    unsigned int    ratio;   ///< aspect ratio of video source
+    void *          param;   ///< other parameters for video decoder
+    unsigned long long ratio64; ///< aspect ratio of video source
+} dec_sysinfo_t;
+
+typedef struct {
+    int valid;               ///< audio extradata valid(1) or invalid(0), set by dsp
+    int sample_rate;         ///< audio stream sample rate
+    int channels;            ///< audio stream channels
+    int bitrate;             ///< audio stream bit rate
+    int codec_id;            ///< codec format id
+    int block_align;         ///< audio block align from ffmpeg
+    int extradata_size;      ///< extra data size
+    char extradata[AUDIO_EXTRA_DATA_SIZE];   ///< extra data information for decoder
+} audio_info_t;
+
+typedef struct {
+    CODEC_HANDLE handle;        ///< codec device handler
+    CODEC_HANDLE cntl_handle;   ///< video control device handler
+    CODEC_HANDLE sub_handle;    ///< subtile device handler
+    stream_type_t stream_type;  ///< stream type(es, ps, rm, ts)
+    unsigned int has_video:1;   ///< stream has video(1) or not(0)
+    unsigned int has_audio:1;   ///< stream has audio(1) or not(0)
+    unsigned int has_sub:1;     ///< stream has subtitle(1) or not(0)
+    unsigned int noblock:1;     ///< codec device is NONBLOCK(1) or not(0)
+    int video_type;             ///< stream video type(H264, VC1...)
+    int audio_type;             ///< stream audio type(PCM, WMA...)
+    int sub_type;               ///< stream subtitle type(TXT, SSA...)
+    int video_pid;              ///< stream video pid
+    int audio_pid;              ///< stream audio pid
+    int sub_pid;                ///< stream subtitle pid
+    int audio_channels;         ///< stream audio channel number
+    int audio_samplerate;       ///< steram audio sample rate
+    int vbuf_size;              ///< video buffer size of codec device
+    int abuf_size;              ///< audio buffer size of codec device
+    dec_sysinfo_t hisi_sysinfo;   ///< system information for video
+    audio_info_t audio_info;    ///< audio information pass to audiodsp
+    int packet_size;            ///< data size per packet
+    int avsync_threshold;       ///<for adec in ms>
+    void * adec_priv;           ///<for adec>
+} codec_para_t;
+
+typedef struct hisi_private_t hisi_private_t;
+
+class DllLibHiSample;
+class DllLibHiComm;
+class DllLibHiMpi;
+
+class CHisiAudioCodec : public CThread
+{
+public:
+  CHisiAudioCodec();
+  virtual ~CHisiAudioCodec();
+
+  bool          OpenDecoder(CDVDStreamInfo &hints);
+  void          CloseDecoder();
+  void          Reset();
+
+  int           Decode(uint8_t *pData, size_t size, double dts);
+  void          SetSpeed(int speed);
+  int           GetDataSize();
+  double        GetTimeSize();
+
+protected:
+  virtual void  Process();
+
+private:
+  void          PauseResume(int state);
+  double        GetPlayerPtsSeconds();
+  void          SetAudioPtsSeconds(double pts);
+
+  DllLibHiSample     *m_dll_sample;
+  DllLibHiComm      *m_dll_comm;
+  DllLibHiMpi           *m_dll_mpi;
+  hisi_private_t  *hisi_private;
+  volatile double m_1st_pts;
+  volatile double m_cur_pts;
+  volatile double m_cur_audcnt;
+  volatile double m_old_audcnt;
+  volatile double  m_timesize;
+  volatile int m_abufsize;
+  CEvent        m_ready_event;
+  int           m_AdecType;
+  unsigned int m_hAvplay;
+  HI_HANDLE m_hTrack;
+  float m_volume;
+  bool m_mute;
+  int           m_speed;
+  bool          m_opened;
+};
+
diff -Naur kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Audio/Makefile.in kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Audio/Makefile.in
--- kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Audio/Makefile.in	2015-10-23 23:53:21.000000000 +0200
+++ kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Audio/Makefile.in	2016-04-09 19:50:08.310429069 +0200
@@ -5,6 +5,11 @@
 SRCS  = DVDAudioCodecFFmpeg.cpp
 SRCS += DVDAudioCodecPassthrough.cpp
 
+ifeq (@USE_LIBHISICODEC@,1)
+SRCS += HISIAudioCodec.cpp
+SRCS += DVDAudioCodecHisi.cpp
+endif 
+
 LIB=Audio.a
 
 include @abs_top_srcdir@/Makefile.include
diff -Naur kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp kodi.work/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
--- kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp	2015-10-23 23:53:21.000000000 +0200
+++ kodi.work/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp	2016-04-09 19:50:16.578429046 +0200
@@ -50,6 +50,12 @@
 #include "Video/DVDVideoCodecAndroidMediaCodec.h"
 #include "android/activity/AndroidFeatures.h"
 #endif
+
+#if defined(HAS_LIBHISICODEC)
+#include "Video/DVDVideoCodecHisi.h"
+#include "Audio/DVDAudioCodecHisi.h"
+#endif
+
 #include "Audio/DVDAudioCodecFFmpeg.h"
 #include "Audio/DVDAudioCodecPassthrough.h"
 #include "Overlay/DVDOverlayCodecSSA.h"
@@ -146,6 +152,13 @@
   //when support for a hardware decoder is not compiled in
   //only print it if it's actually available on the platform
   std::string hwSupport;
+
+#if defined(HAS_LIBHISICODEC)
+  hwSupport += "HISICodec:yes ";
+#else
+  hwSupport += "HISICodec:no ";
+#endif
+
 #if defined(TARGET_DARWIN_OSX)
   hwSupport += "VDADecoder:yes ";
 #endif
@@ -201,6 +214,10 @@
 #endif
   CLog::Log(LOGDEBUG, "CDVDFactoryCodec: compiled in hardware support: %s", hwSupport.c_str());
 
+#if defined(HAS_LIBHISICODEC)
+  if ( (pCodec = OpenCodec(new CDVDVideoCodecHisi(), hint, options)) ) return pCodec;
+#endif
+
   if (hint.stills && (hint.codec == AV_CODEC_ID_MPEG2VIDEO || hint.codec == AV_CODEC_ID_MPEG1VIDEO))
   {
      // If dvd is an mpeg2 and hint.stills
@@ -345,6 +362,16 @@
   CDVDAudioCodec* pCodec = NULL;
   CDVDCodecOptions options;
 
+#if defined(HAS_LIBHISICODEC)
+  CLog::Log(LOGDEBUG, "CDVDFactoryCodec::CreateAudioCodec hint.software(%d)", hint.software);
+  if (!hint.software)
+  {
+    CLog::Log(LOGINFO, "Hisi Audio Decoder...");
+    if ( (pCodec = OpenCodec(new CDVDAudioCodecHisi(), hint, options)) ) return pCodec;
+  }
+  CLog::Log(LOGDEBUG, "Using other Audio Decoder...");
+#endif
+
   // try passthrough first
   pCodec = OpenCodec( new CDVDAudioCodecPassthrough(), hint, options );
   if( pCodec ) return pCodec;
diff -Naur kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Video/DllLibHiComm.h kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Video/DllLibHiComm.h
--- kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Video/DllLibHiComm.h	1970-01-01 01:00:00.000000000 +0100
+++ kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Video/DllLibHiComm.h	2016-04-08 08:02:26.940980439 +0200
@@ -0,0 +1,73 @@
+
+#pragma once
+
+#include "DynamicDll.h"
+#include "hi_common.h"
+
+class DllLibhicommCodecInterface
+{
+public:
+  virtual ~DllLibhicommCodecInterface() {}
+
+  virtual HI_S32 HI_SYS_Init() = 0; //28
+  virtual HI_S32 HI_SYS_DeInit() = 0; //32
+#if 0 //HiSTBLinuxV100R004C00SPC030
+  virtual HI_S32 HI_SYS_PreAV(HI_SYS_PREAV_PARAM_S *pstPreParm) = 0; //36
+#else //HiSTBLinuxV100R003C00SPC020
+  virtual HI_S32 HI_SYS_PreAV(void*) = 0; //36
+#endif
+#if 0
+  DllLibHiComm::HI_SYS_GetPlayTime, //40
+  DllLibHiComm::HI_SYS_GetVersion, //44
+  DllLibHiComm::HI_SYS_SetConf, //48
+  DllLibHiComm::HI_SYS_GetConf, //52
+  DllLibHiComm::HI_SYS_SetLogLevel, //56
+  DllLibHiComm::HI_SYS_WriteRegister, //60
+  DllLibHiComm::HI_SYS_ReadRegister, //64
+  DllLibHiComm::HI_MMZ_Malloc, //68
+  DllLibHiComm::HI_MMZ_Free, //72
+  DllLibHiComm::HI_MMZ_New, //76
+  DllLibHiComm::HI_MMZ_Delete, //80
+  DllLibHiComm::HI_MMZ_Map, //84
+  DllLibHiComm::HI_MMZ_Unmap, //88
+  DllLibHiComm::HI_MMZ_Flush, //92
+  DllLibHiComm::HI_MEM_Map, //96
+  DllLibHiComm::HI_MEM_Unmap, //100
+  DllLibHiComm::HI_MMZ_GetPhyaddr //104
+#endif
+
+};
+
+#if 0
+class DllLibHiComm : public DllDynamic, public DllLibhicommCodecInterface
+{
+  DECLARE_DLL_WRAPPER(DllLibhicomm, "libhi_common.so")
+
+};
+#else
+class DllLibHiComm : public DllLibhicommCodecInterface
+{
+public:
+  virtual ~DllLibHiComm() {}
+  virtual bool Load() { return true; }
+  virtual void Unload() {}
+
+  virtual HI_S32 HI_SYS_Init() { return ::HI_SYS_Init(); }
+  virtual HI_S32 HI_SYS_DeInit() { return ::HI_SYS_DeInit(); }
+#if 0 //HiSTBLinuxV100R004C00SPC030
+  virtual HI_S32 HI_SYS_PreAV(HI_SYS_PREAV_PARAM_S *pstPreParm)
+  {
+    return ::HI_SYS_PreAV(pstPreParm);
+  }
+#else //HiSTBLinuxV100R003C00SPC020
+  virtual HI_S32 HI_SYS_PreAV(void*)
+  {
+    return HI_SUCCESS;
+  }
+#endif
+
+};
+#endif
+
+
+
diff -Naur kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Video/DllLibHiMpi.h kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Video/DllLibHiMpi.h
--- kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Video/DllLibHiMpi.h	1970-01-01 01:00:00.000000000 +0100
+++ kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Video/DllLibHiMpi.h	2016-04-15 15:32:42.108771164 +0200
@@ -0,0 +1,218 @@
+
+#pragma once
+
+#include "DynamicDll.h"
+#include "hi_unf_avplay.h"
+#include "hi_unf_vo.h"
+
+class DllLibhimpiCodecInterface
+{
+public:
+  virtual ~DllLibhimpiCodecInterface() {}
+
+  virtual HI_S32 HI_UNF_AVPLAY_Init() = 0; //28
+  virtual HI_S32 HI_UNF_AVPLAY_DeInit() = 0; //32
+  virtual HI_S32 HI_UNF_AVPLAY_GetDefaultConfig(HI_UNF_AVPLAY_ATTR_S*, HI_UNF_AVPLAY_STREAM_TYPE_E) = 0; //36
+  virtual HI_S32 HI_UNF_AVPLAY_Create(const HI_UNF_AVPLAY_ATTR_S*, HI_HANDLE*) = 0; //40
+  virtual HI_S32 HI_UNF_AVPLAY_Destroy(HI_HANDLE hAvplay) = 0; //44
+  virtual HI_S32 HI_UNF_AVPLAY_SetAttr(HI_HANDLE, HI_UNF_AVPLAY_ATTR_ID_E, HI_VOID*) = 0; //48
+  virtual HI_S32 HI_UNF_AVPLAY_GetAttr(HI_HANDLE, HI_UNF_AVPLAY_ATTR_ID_E, HI_VOID*) = 0; //52
+  virtual HI_S32 HI_UNF_AVPLAY_RegisterEvent(HI_HANDLE hAvplay, HI_UNF_AVPLAY_EVENT_E enEvent, HI_UNF_AVPLAY_EVENT_CB_FN pfnEventCB) = 0; //56
+  virtual HI_S32 HI_UNF_AVPLAY_UnRegisterEvent(HI_HANDLE hAvplay, HI_UNF_AVPLAY_EVENT_E enEvent) = 0; //60
+  virtual HI_S32 HI_UNF_AVPLAY_ChnOpen(HI_HANDLE, HI_UNF_AVPLAY_MEDIA_CHAN_E, const HI_VOID*) = 0; //64
+  virtual HI_S32 HI_UNF_AVPLAY_ChnClose(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn) = 0; //68
+  virtual HI_S32 HI_UNF_AVPLAY_Start(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn, const HI_UNF_AVPLAY_START_OPT_S *pstStartOpt) = 0; //72
+  virtual HI_S32 HI_UNF_AVPLAY_Stop(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn, const HI_UNF_AVPLAY_STOP_OPT_S *pstStopOpt) = 0; //76
+  virtual HI_S32 HI_UNF_AVPLAY_Pause(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_PAUSE_OPT_S *pstPauseOpt) = 0; //80
+  virtual HI_S32 HI_UNF_AVPLAY_Resume(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_RESUME_OPT_S *pstResumeOpt) = 0; //84
+  virtual HI_S32 HI_UNF_AVPLAY_GetBuf(HI_HANDLE  hAvplay, HI_UNF_AVPLAY_BUFID_E enBufId,
+          HI_U32                u32ReqLen,
+          HI_UNF_STREAM_BUF_S  *pstData,
+          HI_U32                u32TimeOutMs) = 0; //88
+  virtual HI_S32 HI_UNF_AVPLAY_PutBuf(HI_HANDLE hAvplay, HI_UNF_AVPLAY_BUFID_E enBufId,
+                           HI_U32 u32ValidDataLen, HI_U32 u32PtsMs) = 0; //92
+  virtual HI_S32 HI_UNF_AVPLAY_GetStatusInfo(HI_HANDLE hAvplay, HI_UNF_AVPLAY_STATUS_INFO_S *pstStatusInfo) = 0; //96
+  virtual HI_S32 HI_UNF_AVPLAY_GetStreamInfo(HI_HANDLE hAvplay, HI_UNF_AVPLAY_STREAM_INFO_S *pstStreamInfo) = 0;
+  virtual HI_S32 HI_UNF_SND_Attach(HI_HANDLE hTrack, HI_HANDLE hSource) = 0; //100
+  virtual HI_S32 HI_UNF_SND_Detach(HI_HANDLE hTrack, HI_HANDLE hSource) = 0; //104
+  virtual HI_S32 HI_UNF_VO_Init(HI_UNF_VO_DEV_MODE_E enDevMode) = 0; //128
+#if 0 //HiSTBLinuxV100R004C00SPC030
+  virtual HI_S32 HI_UNF_VO_Open(HI_UNF_VO_E enVo) = 0; //132
+#else //HiSTBLinuxV100R003C00SPC020
+  virtual HI_S32 HI_UNF_VO_Open(int) = 0; //132
+#endif
+  virtual HI_S32 HI_UNF_VO_CreateWindow(const HI_UNF_WINDOW_ATTR_S*, HI_HANDLE*) = 0; //136
+  virtual HI_S32 HI_UNF_VO_DestroyWindow(HI_HANDLE hWindow) = 0; //140
+  virtual HI_S32 HI_UNF_VO_AttachWindow(HI_HANDLE, HI_HANDLE) = 0; //144
+  virtual HI_S32 HI_UNF_VO_DetachWindow(HI_HANDLE hWindow, HI_HANDLE hSrc) = 0; //148
+  virtual HI_S32 HI_UNF_VO_SetWindowEnable(HI_HANDLE hWindow, HI_BOOL bEnable) = 0; //152
+  virtual HI_S32 HI_UNF_DISP_SetLayerZorder(HI_UNF_DISP_E, HI_UNF_DISP_LAYER_E, HI_LAYER_ZORDER_E) = 0; //156
+#if 0
+	  DllLibHiMpi::HI_UNF_SND_SetSpdifPassThrough, //108
+	  DllLibHiMpi::HI_UNF_SND_SetHdmiPassThrough, //112
+	  DllLibHiMpi::HI_UNF_SND_SetVolume, //116
+	  DllLibHiMpi::HI_UNF_SND_GetVolume, //120
+	  DllLibHiMpi::HI_UNF_SND_SetMute, //124
+	  DllLibHiMpi::HI_UNF_VO_CreateWindow, //136
+	  DllLibHiMpi::HI_UNF_SND_Open, //160
+	  DllLibHiMpi::HI_UNF_SND_Close //164
+#endif
+
+#if 1 //Spitzbube: new SDK
+  virtual HI_S32 HI_UNF_SND_GetDefaultTrackAttr(HI_UNF_SND_TRACK_TYPE_E enTrackType, HI_UNF_AUDIOTRACK_ATTR_S *pstAttr) = 0;
+  virtual HI_S32 HI_UNF_SND_CreateTrack(HI_UNF_SND_E enSound,const HI_UNF_AUDIOTRACK_ATTR_S *pTrackAttr,HI_HANDLE *phTrack) = 0;
+  virtual HI_S32 HI_UNF_SND_DestroyTrack(HI_HANDLE hTrack) = 0;
+  virtual HI_S32 HI_UNF_SND_SetSpdifMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_SPDIF_MODE_E enSpdifMode) = 0;
+  virtual HI_S32 HI_UNF_SND_SetHdmiMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_HDMI_MODE_E enHdmiMode) = 0;
+#endif
+};
+
+#if 0
+class DllLibHiMpi : public DllDynamic, public DllLibhimpiCodecInterface
+{
+  DECLARE_DLL_WRAPPER(DllLibHiMpi, "libhi_mpi.so")
+
+};
+#else
+class DllLibHiMpi : public DllLibhimpiCodecInterface
+{
+public:
+  virtual ~DllLibHiMpi() {}
+  virtual bool Load() { return true; }
+  virtual void Unload() {}
+
+  virtual HI_S32 HI_UNF_AVPLAY_Init() { return ::HI_UNF_AVPLAY_Init(); }
+  virtual HI_S32 HI_UNF_AVPLAY_DeInit() { return ::HI_UNF_AVPLAY_DeInit(); }
+  virtual HI_S32 HI_UNF_AVPLAY_GetDefaultConfig(HI_UNF_AVPLAY_ATTR_S *pstAvAttr, HI_UNF_AVPLAY_STREAM_TYPE_E enCfg)
+  {
+    return ::HI_UNF_AVPLAY_GetDefaultConfig(pstAvAttr, enCfg);
+  }
+  virtual HI_S32 HI_UNF_AVPLAY_Create(const HI_UNF_AVPLAY_ATTR_S *pstAvAttr, HI_HANDLE *phAvplay)
+  {
+    return ::HI_UNF_AVPLAY_Create(pstAvAttr, phAvplay);
+  }
+  virtual HI_S32 HI_UNF_AVPLAY_Destroy(HI_HANDLE hAvplay) { return ::HI_UNF_AVPLAY_Destroy(hAvplay); }
+  virtual HI_S32 HI_UNF_AVPLAY_SetAttr(HI_HANDLE hAvplay, HI_UNF_AVPLAY_ATTR_ID_E enAttrID, HI_VOID *pPara)
+  {
+    return ::HI_UNF_AVPLAY_SetAttr(hAvplay, enAttrID, pPara);
+  }
+  virtual HI_S32 HI_UNF_AVPLAY_GetAttr(HI_HANDLE hAvplay, HI_UNF_AVPLAY_ATTR_ID_E enAttrID, HI_VOID *pPara)
+  {
+    return ::HI_UNF_AVPLAY_GetAttr(hAvplay, enAttrID, pPara);
+  }
+  virtual HI_S32 HI_UNF_AVPLAY_RegisterEvent(HI_HANDLE hAvplay, HI_UNF_AVPLAY_EVENT_E enEvent, HI_UNF_AVPLAY_EVENT_CB_FN pfnEventCB)
+  {
+    return ::HI_UNF_AVPLAY_RegisterEvent(hAvplay, enEvent, pfnEventCB);
+  }
+  virtual HI_S32 HI_UNF_AVPLAY_UnRegisterEvent(HI_HANDLE hAvplay, HI_UNF_AVPLAY_EVENT_E enEvent)
+  {
+    return ::HI_UNF_AVPLAY_UnRegisterEvent(hAvplay, enEvent);
+  }
+  virtual HI_S32 HI_UNF_AVPLAY_ChnOpen(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn, const HI_VOID *pPara)
+  {
+    return ::HI_UNF_AVPLAY_ChnOpen(hAvplay, enChn, pPara);
+  }
+  virtual HI_S32 HI_UNF_AVPLAY_ChnClose(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn)
+  {
+    return ::HI_UNF_AVPLAY_ChnClose(hAvplay, enChn);
+  }
+  virtual HI_S32 HI_UNF_AVPLAY_Start(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn, const HI_UNF_AVPLAY_START_OPT_S *pstStartOpt)
+  {
+	return ::HI_UNF_AVPLAY_Start(hAvplay, enChn, pstStartOpt);
+  }
+  virtual HI_S32 HI_UNF_AVPLAY_Stop(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn, const HI_UNF_AVPLAY_STOP_OPT_S *pstStopOpt)
+  {
+    return ::HI_UNF_AVPLAY_Stop(hAvplay, enChn, pstStopOpt);
+  }
+  virtual HI_S32 HI_UNF_AVPLAY_Pause(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_PAUSE_OPT_S *pstPauseOpt)
+  {
+    return ::HI_UNF_AVPLAY_Pause(hAvplay, pstPauseOpt);
+  }
+  virtual HI_S32 HI_UNF_AVPLAY_Resume(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_RESUME_OPT_S *pstResumeOpt)
+  {
+    return ::HI_UNF_AVPLAY_Resume(hAvplay, pstResumeOpt);
+  }
+  virtual HI_S32 HI_UNF_AVPLAY_GetBuf(HI_HANDLE  hAvplay, HI_UNF_AVPLAY_BUFID_E enBufId,
+          HI_U32                u32ReqLen,
+          HI_UNF_STREAM_BUF_S  *pstData,
+          HI_U32                u32TimeOutMs)
+  {
+    return ::HI_UNF_AVPLAY_GetBuf(hAvplay, enBufId, u32ReqLen, pstData, u32TimeOutMs);
+  }
+  virtual HI_S32 HI_UNF_AVPLAY_PutBuf(HI_HANDLE hAvplay, HI_UNF_AVPLAY_BUFID_E enBufId,
+                           HI_U32 u32ValidDataLen, HI_U32 u32PtsMs)
+  {
+    return ::HI_UNF_AVPLAY_PutBuf(hAvplay, enBufId, u32ValidDataLen, u32PtsMs);
+  }
+  virtual HI_S32 HI_UNF_AVPLAY_GetStatusInfo(HI_HANDLE hAvplay, HI_UNF_AVPLAY_STATUS_INFO_S *pstStatusInfo)
+  {
+    return ::HI_UNF_AVPLAY_GetStatusInfo(hAvplay, pstStatusInfo);
+  }
+  virtual HI_S32 HI_UNF_AVPLAY_GetStreamInfo(HI_HANDLE hAvplay, HI_UNF_AVPLAY_STREAM_INFO_S *pstStreamInfo)
+  {
+    return ::HI_UNF_AVPLAY_GetStreamInfo(hAvplay, pstStreamInfo);
+  }
+  virtual HI_S32 HI_UNF_SND_Attach(HI_HANDLE hTrack, HI_HANDLE hSource)
+  {
+    return ::HI_UNF_SND_Attach(hTrack, hSource);
+  }
+  virtual HI_S32 HI_UNF_SND_Detach(HI_HANDLE hTrack, HI_HANDLE hSource)
+  {
+    return ::HI_UNF_SND_Detach(hTrack, hSource);
+  }
+  virtual HI_S32 HI_UNF_VO_Init(HI_UNF_VO_DEV_MODE_E enDevMode) { return ::HI_UNF_VO_Init(enDevMode); }
+#if 0 //HiSTBLinuxV100R004C00SPC030
+  virtual HI_S32 HI_UNF_VO_Open(HI_UNF_VO_E enVo) { return ::HI_UNF_VO_Open(enVo); }
+#else //HiSTBLinuxV100R003C00SPC020
+  virtual HI_S32 HI_UNF_VO_Open(int) { return HI_SUCCESS; }
+#endif
+  virtual HI_S32 HI_UNF_VO_CreateWindow(const HI_UNF_WINDOW_ATTR_S *pWinAttr, HI_HANDLE *phWindow)
+  {
+    return ::HI_UNF_VO_CreateWindow(pWinAttr, phWindow);
+  }
+  virtual HI_S32 HI_UNF_VO_DestroyWindow(HI_HANDLE hWindow) { return ::HI_UNF_VO_DestroyWindow(hWindow); }
+  virtual HI_S32 HI_UNF_VO_AttachWindow(HI_HANDLE hWindow, HI_HANDLE hSrc)
+  {
+    return ::HI_UNF_VO_AttachWindow(hWindow, hSrc);
+  }
+  virtual HI_S32 HI_UNF_VO_DetachWindow(HI_HANDLE hWindow, HI_HANDLE hSrc)
+  {
+    return ::HI_UNF_VO_DetachWindow(hWindow, hSrc);
+  }
+  virtual HI_S32 HI_UNF_VO_SetWindowEnable(HI_HANDLE hWindow, HI_BOOL bEnable)
+  {
+	return ::HI_UNF_VO_SetWindowEnable(hWindow, bEnable);
+  }
+  virtual HI_S32 HI_UNF_DISP_SetLayerZorder(HI_UNF_DISP_E enDisp, HI_UNF_DISP_LAYER_E enLayer, HI_LAYER_ZORDER_E enZFlag)
+  {
+    return ::HI_UNF_DISP_SetLayerZorder(enDisp, enLayer, enZFlag);
+  }
+
+#if 1 //Spitzbube: new SDK
+  virtual HI_S32 HI_UNF_SND_GetDefaultTrackAttr(HI_UNF_SND_TRACK_TYPE_E enTrackType, HI_UNF_AUDIOTRACK_ATTR_S *pstAttr)
+  {
+    return ::HI_UNF_SND_GetDefaultTrackAttr(enTrackType, pstAttr);
+  }
+  virtual HI_S32 HI_UNF_SND_CreateTrack(HI_UNF_SND_E enSound,const HI_UNF_AUDIOTRACK_ATTR_S *pTrackAttr,HI_HANDLE *phTrack)
+  {
+    return ::HI_UNF_SND_CreateTrack(enSound, pTrackAttr, phTrack);
+  }
+  virtual HI_S32 HI_UNF_SND_DestroyTrack(HI_HANDLE hTrack)
+  {
+    return ::HI_UNF_SND_DestroyTrack(hTrack);
+  }
+  virtual HI_S32 HI_UNF_SND_SetSpdifMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_SPDIF_MODE_E enSpdifMode)
+  {
+    return ::HI_UNF_SND_SetSpdifMode(enSound, enOutPort, enSpdifMode);
+  }
+  virtual HI_S32 HI_UNF_SND_SetHdmiMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_HDMI_MODE_E enHdmiMode)
+  {
+    return ::HI_UNF_SND_SetHdmiMode(enSound, enOutPort, enHdmiMode);
+  }
+#endif
+
+};
+#endif
+
+
+
diff -Naur kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Video/DllLibHiSample.cpp kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Video/DllLibHiSample.cpp
--- kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Video/DllLibHiSample.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Video/DllLibHiSample.cpp	2016-04-13 17:23:17.784864648 +0200
@@ -0,0 +1,339 @@
+
+
+#include "DllLibHiSample.h"
+#include "utils/log.h"
+#include "hi_unf_avplay.h"
+#include "hi_unf_sound.h"
+
+#define DOLBYPLUS_HACODEC_SUPPORT
+
+#include "HA.AUDIO.G711.codec.h"
+#include "HA.AUDIO.MP3.decode.h"
+#include "HA.AUDIO.MP2.decode.h"
+#include "HA.AUDIO.AAC.decode.h"
+#include "HA.AUDIO.DRA.decode.h"
+#include "HA.AUDIO.PCM.decode.h"
+#include "HA.AUDIO.WMA9STD.decode.h"
+#include "HA.AUDIO.AMRNB.codec.h"
+#include "HA.AUDIO.AMRWB.codec.h"
+#include "HA.AUDIO.TRUEHDPASSTHROUGH.decode.h"
+#include "HA.AUDIO.DOLBYTRUEHD.decode.h"
+#include "HA.AUDIO.DTSHD.decode.h"
+#if defined (DOLBYPLUS_HACODEC_SUPPORT)
+ #include "HA.AUDIO.DOLBYPLUS.decode.h"
+#endif
+#include "HA.AUDIO.AC3PASSTHROUGH.decode.h"
+#include "HA.AUDIO.DTSM6.decode.h"
+
+#include "HA.AUDIO.DTSPASSTHROUGH.decode.h"
+#include "HA.AUDIO.FFMPEG_DECODE.decode.h"
+#include "HA.AUDIO.AAC.encode.h"
+
+
+#define NORMAL_PCM_EXTWORD    1
+
+static HI_U8 u8DecOpenBuf[1024];
+
+#if defined (DOLBYPLUS_HACODEC_SUPPORT)
+
+DOLBYPLUS_STREAM_INFO_S g_stDDpStreamInfo;
+
+/*dolby Dual Mono type control*/
+HI_U32  g_u32DolbyAcmod = 0;
+HI_BOOL g_bDrawChnBar = HI_TRUE;
+
+#endif
+
+
+HI_S32 DllLibHiSample::HIADP_VO_Init(HI_UNF_VO_DEV_MODE_E enDevMode)
+{
+  CLog::Log(LOGDEBUG, "DllLibHiSample::HIADP_VO_Init - TODO");
+
+  return HI_SUCCESS;
+}
+
+HI_S32 DllLibHiSample::HIADP_VO_DeInit()
+{
+  CLog::Log(LOGDEBUG, "DllLibHiSample::HIADP_VO_DeInit - TODO");
+
+  return HI_SUCCESS;
+}
+
+HI_S32 DllLibHiSample::HIADP_Snd_Init()
+{
+  HI_S32                  Ret;
+  HI_UNF_SND_ATTR_S       stAttr;
+
+  Ret = ::HI_UNF_SND_Init();
+  if (Ret != HI_SUCCESS)
+  {
+	CLog::Log(LOGERROR, "DllLibHiSample::HIADP_Snd_Init: HI_UNF_SND_Init failed:%#x\n",Ret);
+    return Ret;
+  }
+
+  Ret = ::HI_UNF_SND_GetDefaultOpenAttr(HI_UNF_SND_0, &stAttr);
+  if (Ret != HI_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "DllLibHiSample::HIADP_Snd_Init: HI_UNF_SND_GetDefaultOpenAttr failed:%#x\n",Ret);
+    return Ret;
+  }
+
+  Ret = ::HI_UNF_SND_Open(HI_UNF_SND_0, &stAttr);
+  if (Ret != HI_SUCCESS)
+  {
+	CLog::Log(LOGERROR, "DllLibHiSample::HIADP_Snd_Init: HI_UNF_SND_Open failed:%#x\n",Ret);
+    return Ret;
+  }
+
+  return HI_SUCCESS;
+}
+
+
+HI_S32 DllLibHiSample::HIADP_Disp_Init(HI_UNF_ENC_FMT_E enFormat)
+{
+  CLog::Log(LOGDEBUG, "DllLibHiSample::HIADP_Disp_Init - TODO");
+
+  return HI_SUCCESS;
+}
+
+HI_S32 DllLibHiSample::HIADP_Disp_DeInit()
+{
+  CLog::Log(LOGDEBUG, "DllLibHiSample::HIADP_Disp_DeInit - TODO");
+
+  return HI_SUCCESS;
+}
+
+HI_S32 DllLibHiSample::HIADP_AVPlay_RegADecLib()
+{
+    HI_S32 Ret = HI_SUCCESS;
+
+    Ret = ::HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.AMRWB.codec.so");
+    Ret |= ::HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.MP3.decode.so");
+    Ret |= ::HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.MP2.decode.so");
+    Ret |= ::HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.AAC.decode.so");
+//    Ret |= ::HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.DOLBYTRUEHD.decode.so");
+    Ret |= ::HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.DRA.decode.so");
+    Ret |= ::HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.TRUEHDPASSTHROUGH.decode.so");
+    Ret |= ::HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.AMRNB.codec.so");
+    Ret |= ::HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.WMA.decode.so");
+    Ret |= ::HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.COOK.decode.so");
+    Ret |= ::HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.DOLBYPLUS.decode.so");
+//    Ret |= ::HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.DTSHD.decode.so");
+//    Ret |= ::HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.DTSM6.decode.so");
+    Ret |= ::HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.DTSPASSTHROUGH.decode.so");
+    Ret |= ::HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.AC3PASSTHROUGH.decode.so");
+    Ret |= ::HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.PCM.decode.so");
+
+    if (Ret != HI_SUCCESS)
+    {
+      CLog::Log(LOGERROR, "DllLibHiSample::HIADP_AVPlay_RegADecLib: some audio codec NOT found. you may NOT able to decode some audio type:%#x\n",Ret);
+    }
+
+    return HI_SUCCESS;
+}
+
+HI_S32 DllLibHiSample::HIADP_AVPlay_SetVdecAttr(HI_HANDLE hAvplay,HI_UNF_VCODEC_TYPE_E enType,HI_UNF_VCODEC_MODE_E enMode)
+{
+  HI_S32 Ret;
+  HI_UNF_VCODEC_ATTR_S        VdecAttr;
+
+  Ret = ::HI_UNF_AVPLAY_GetAttr(hAvplay, HI_UNF_AVPLAY_ATTR_ID_VDEC, &VdecAttr);
+  if (HI_SUCCESS != Ret)
+  {
+	  CLog::Log(LOGERROR, "DllLibHiSample::HIADP_AVPlay_SetVdecAttr: HI_UNF_AVPLAY_GetAttr failed:%#x\n",Ret);
+      return Ret;
+  }
+
+  VdecAttr.enType = enType;
+  VdecAttr.enMode = enMode;
+  VdecAttr.u32ErrCover = 100;
+  VdecAttr.u32Priority = 3;
+
+  Ret = ::HI_UNF_AVPLAY_SetAttr(hAvplay, HI_UNF_AVPLAY_ATTR_ID_VDEC, &VdecAttr);
+  if (Ret != HI_SUCCESS)
+  {
+	  CLog::Log(LOGERROR, "DllLibHiSample::HIADP_AVPlay_SetVdecAttr: call HI_UNF_AVPLAY_SetAttr failed.\n");
+      return Ret;
+  }
+
+  return Ret;
+}
+
+#if defined (DOLBYPLUS_HACODEC_SUPPORT)
+
+static HI_VOID DDPlusCallBack(DOLBYPLUS_EVENT_E Event, HI_VOID *pUserData)
+{
+    DOLBYPLUS_STREAM_INFO_S *pstInfo = (DOLBYPLUS_STREAM_INFO_S *)pUserData;
+#if 1
+    CLog::Log(LOGDEBUG, "DDPlusCallBack show info:\n \
+                s16StreamType          = %d\n \
+                s16Acmod               = %d\n \
+                s32BitRate             = %d\n \
+                s32SampleRateRate      = %d\n \
+                Event                  = %d\n",
+                pstInfo->s16StreamType, pstInfo->s16Acmod, pstInfo->s32BitRate, pstInfo->s32SampleRateRate,Event);
+#endif
+    g_u32DolbyAcmod = pstInfo->s16Acmod;
+
+    if (HA_DOLBYPLUS_EVENT_SOURCE_CHANGE == Event)
+    {
+        g_bDrawChnBar = HI_TRUE;
+        //printf("DDPlusCallBack enent !\n");
+    }
+    return;
+}
+
+#endif
+
+HI_S32 DllLibHiSample::HIADP_AVPlay_SetAdecAttr(HI_HANDLE hAvplay,HI_U32 enADecType,HI_HA_DECODEMODE_E enMode, HI_S32 isCoreOnly)
+{
+    HI_S32 Ret;
+    HI_UNF_ACODEC_ATTR_S AdecAttr;
+    WAV_FORMAT_S stWavFormat;
+
+    Ret = ::HI_UNF_AVPLAY_GetAttr(hAvplay, HI_UNF_AVPLAY_ATTR_ID_ADEC, &AdecAttr);
+    if (Ret != HI_SUCCESS)
+    {
+  	  CLog::Log(LOGERROR, "DllLibHiSample::HIADP_AVPlay_SetAdecAttr: HI_UNF_AVPLAY_GetAttr failed:%#x\n",Ret);
+      return Ret;
+    }
+
+    AdecAttr.enType = (HA_CODEC_ID_E) enADecType;
+
+    if (HA_AUDIO_ID_PCM == AdecAttr.enType)
+    {
+        HI_BOOL isBigEndian;
+
+        /* if big-endian pcm */
+        isBigEndian = HI_FALSE;
+        if(HI_TRUE == isBigEndian)
+        {
+            stWavFormat.cbSize = 4;
+            stWavFormat.cbExtWord[0] = NORMAL_PCM_EXTWORD; //choose normal pcm decoder
+            //stWavFormat.cbExtWord[0] = WIFIDSP_LPCM_EXTWORD; //choose wifi_dsp_lpcm decoder
+        }
+
+        if(stWavFormat.cbExtWord[0] == NORMAL_PCM_EXTWORD || HI_FALSE == isBigEndian)
+        {
+        /*
+            if choose normal pcm decoder, set attribute
+            if choose wifi_dsp_lpcm decoder, need not to set attribute by follows, ignore it
+        */
+        /* set pcm wav format here base on pcm file */
+            stWavFormat.nChannels = 1;
+            stWavFormat.nSamplesPerSec = 48000;
+            stWavFormat.wBitsPerSample = 16;
+        }
+        HA_PCM_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam),&stWavFormat);
+#if 0
+        sample_common_printf("please make sure the attributes of PCM stream is tme same as defined in function of \"HIADP_AVPlay_SetAdecAttr\"? \n");
+        sample_common_printf("(nChannels = 1, wBitsPerSample = 16, nSamplesPerSec = 48000, isBigEndian = HI_FALSE) \n");
+#endif
+    }
+#if 0
+    else if (HA_AUDIO_ID_G711 == AdecAttr.enType)
+    {
+         HA_G711_GetDecDefalutOpenParam(&(AdecAttr.stDecodeParam));
+    }
+#endif
+    else if (HA_AUDIO_ID_MP2 == AdecAttr.enType)
+    {
+         HA_MP2_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam));
+    }
+    else if (HA_AUDIO_ID_AAC == AdecAttr.enType)
+    {
+         HA_AAC_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam));
+    }
+    else if (HA_AUDIO_ID_MP3 == AdecAttr.enType)
+    {
+         HA_MP3_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam));
+    }
+    else if (HA_AUDIO_ID_AMRNB== AdecAttr.enType)
+    {
+        AMRNB_DECODE_OPENCONFIG_S *pstConfig = (AMRNB_DECODE_OPENCONFIG_S *)u8DecOpenBuf;
+        HA_AMRNB_GetDecDefalutOpenParam(&(AdecAttr.stDecodeParam), pstConfig);
+        pstConfig->enFormat = AMRNB_MIME;
+    }
+    else if (HA_AUDIO_ID_AMRWB== AdecAttr.enType)
+    {
+        AMRWB_DECODE_OPENCONFIG_S *pstConfig = (AMRWB_DECODE_OPENCONFIG_S *)u8DecOpenBuf;
+        HA_AMRWB_GetDecDefalutOpenParam(&(AdecAttr.stDecodeParam), pstConfig);
+        pstConfig->enFormat = AMRWB_FORMAT_MIME;
+    }
+    else if (HA_AUDIO_ID_AC3PASSTHROUGH== AdecAttr.enType)
+    {
+        HA_AC3PASSTHROUGH_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam));
+        AdecAttr.stDecodeParam.enDecMode = HD_DEC_MODE_THRU;
+    }
+    else if(HA_AUDIO_ID_DTSPASSTHROUGH ==  AdecAttr.enType)
+    {
+                HA_DTSPASSTHROUGH_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam));
+             AdecAttr.stDecodeParam.enDecMode = HD_DEC_MODE_THRU;
+    }
+    else if (HA_AUDIO_ID_TRUEHD == AdecAttr.enType)
+    {
+        HA_TRUEHD_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam));
+        if (HD_DEC_MODE_THRU != enMode)
+        {
+#if 0
+            sample_common_printf(" MLP decoder enMode(%d) error (mlp only support hbr Pass-through only).\n", enMode);
+#endif
+            return -1;
+        }
+
+        AdecAttr.stDecodeParam.enDecMode = HD_DEC_MODE_THRU;        /* truehd just support pass-through */
+#if 0
+        sample_common_printf(" TrueHD decoder(HBR Pass-through only).\n");
+#endif
+    }
+    else if (HA_AUDIO_ID_DOLBY_TRUEHD == AdecAttr.enType)
+    {
+          TRUEHD_DECODE_OPENCONFIG_S *pstConfig = (TRUEHD_DECODE_OPENCONFIG_S *)u8DecOpenBuf;
+        HA_DOLBY_TRUEHD_DecGetDefalutOpenConfig(pstConfig);
+        HA_DOLBY_TRUEHD_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam), pstConfig);
+    }
+    else if (HA_AUDIO_ID_DTSHD == AdecAttr.enType)
+    {
+        DTSHD_DECODE_OPENCONFIG_S *pstConfig = (DTSHD_DECODE_OPENCONFIG_S *)u8DecOpenBuf;
+        HA_DTSHD_DecGetDefalutOpenConfig(pstConfig);
+        HA_DTSHD_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam), pstConfig);
+        AdecAttr.stDecodeParam.enDecMode = HD_DEC_MODE_SIMUL;
+    }
+    else if (HA_AUDIO_ID_DTSM6 == AdecAttr.enType)
+    {
+        DTSM6_DECODE_OPENCONFIG_S *pstConfig = (DTSM6_DECODE_OPENCONFIG_S *)u8DecOpenBuf;
+        HA_DTSM6_DecGetDefalutOpenConfig(pstConfig);
+        HA_DTSM6_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam), pstConfig);
+    }
+#if defined (DOLBYPLUS_HACODEC_SUPPORT)
+    else if (HA_AUDIO_ID_DOLBY_PLUS == AdecAttr.enType)
+    {
+        DOLBYPLUS_DECODE_OPENCONFIG_S *pstConfig = (DOLBYPLUS_DECODE_OPENCONFIG_S *)u8DecOpenBuf;
+        HA_DOLBYPLUS_DecGetDefalutOpenConfig(pstConfig);
+        pstConfig->pfnEvtCbFunc[HA_DOLBYPLUS_EVENT_SOURCE_CHANGE] = DDPlusCallBack;
+        pstConfig->pAppData[HA_DOLBYPLUS_EVENT_SOURCE_CHANGE] = &g_stDDpStreamInfo;
+        /* Dolby DVB Broadcast default settings */
+        pstConfig->enDrcMode = DOLBYPLUS_DRC_RF;
+        pstConfig->enDmxMode = DOLBYPLUS_DMX_SRND;
+        HA_DOLBYPLUS_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam), pstConfig);
+        AdecAttr.stDecodeParam.enDecMode = HD_DEC_MODE_SIMUL;
+    }
+#endif
+    else
+    {
+//       HA_DRA_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam));
+         HA_DRA_DecGetOpenParam_MultichPcm(&(AdecAttr.stDecodeParam));
+    }
+
+    Ret = ::HI_UNF_AVPLAY_SetAttr(hAvplay, HI_UNF_AVPLAY_ATTR_ID_ADEC, &AdecAttr);
+    if (Ret != HI_SUCCESS)
+    {
+  	  CLog::Log(LOGERROR, "DllLibHiSample::HIADP_AVPlay_SetAdecAttr: HI_UNF_AVPLAY_SetAttr failed:%#x\n",Ret);
+      return Ret;
+    }
+
+    return HI_SUCCESS;
+}
+
+
+
diff -Naur kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Video/DllLibHiSample.h kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Video/DllLibHiSample.h
--- kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Video/DllLibHiSample.h	1970-01-01 01:00:00.000000000 +0100
+++ kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Video/DllLibHiSample.h	2016-04-10 15:16:40.312002011 +0200
@@ -0,0 +1,55 @@
+
+#pragma once
+
+#include "DynamicDll.h"
+#include "hi_unf_vo.h"
+
+class DllLibhisampleCodecInterface
+{
+public:
+  virtual ~DllLibhisampleCodecInterface() {}
+
+  virtual HI_S32 HIADP_VO_Init(HI_UNF_VO_DEV_MODE_E) = 0; //28
+  virtual HI_S32 HIADP_VO_DeInit() = 0; //36
+  virtual HI_S32 HIADP_Snd_Init() = 0; //40
+  virtual HI_S32 HIADP_Disp_Init(HI_UNF_ENC_FMT_E enFormat) = 0; //48
+  virtual HI_S32 HIADP_Disp_DeInit() = 0; //52
+  virtual HI_S32 HIADP_AVPlay_RegADecLib() = 0; //56
+  virtual HI_S32 HIADP_AVPlay_SetVdecAttr(HI_HANDLE hAvplay,HI_UNF_VCODEC_TYPE_E enType,HI_UNF_VCODEC_MODE_E enMode) = 0; //64
+  virtual HI_S32 HIADP_AVPlay_SetAdecAttr(HI_HANDLE hAvplay,HI_U32 enADecType,HI_HA_DECODEMODE_E enMode, HI_S32 isCoreOnly) = 0; //72
+#if 0
+	  DllLibHiSample::HIADP_VO_CreatWin, //32
+	  DllLibHiSample::HIADP_Snd_DeInit, //44
+	  DllLibHiSample::HIADP_Disp_Init, //48
+	  DllLibHiSample::HIADP_AVPlay_Init, //60
+	  DllLibHiSample::HIADP_AVPlay_SetVdecAdvAttr, //68
+#endif
+};
+
+#if 0
+class DllLibHiSample : public DllDynamic, public DllLibhisampleCodecInterface
+{
+  DECLARE_DLL_WRAPPER(DllLibHiSample, "libsample_common.so")
+
+};
+#else
+class DllLibHiSample : public DllLibhisampleCodecInterface
+{
+public:
+  virtual ~DllLibHiSample() {}
+  virtual bool Load() { return true; }
+  virtual void Unload() {}
+
+  virtual HI_S32 HIADP_VO_Init(HI_UNF_VO_DEV_MODE_E enDevMode);
+  virtual HI_S32 HIADP_VO_DeInit();
+  virtual HI_S32 HIADP_Snd_Init();
+  virtual HI_S32 HIADP_Disp_Init(HI_UNF_ENC_FMT_E enFormat);
+  virtual HI_S32 HIADP_Disp_DeInit();
+  virtual HI_S32 HIADP_AVPlay_RegADecLib();
+  virtual HI_S32 HIADP_AVPlay_SetVdecAttr(HI_HANDLE hAvplay,HI_UNF_VCODEC_TYPE_E enType,HI_UNF_VCODEC_MODE_E enMode);
+  virtual HI_S32 HIADP_AVPlay_SetAdecAttr(HI_HANDLE hAvplay,HI_U32 enADecType,HI_HA_DECODEMODE_E enMode, HI_S32 isCoreOnly);
+};
+#endif
+
+
+
diff -Naur kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
--- kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h	2015-10-23 23:53:21.000000000 +0200
+++ kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h	2016-04-11 09:41:17.149014371 +0200
@@ -239,6 +239,14 @@
   virtual void SetDropState(bool bDrop) = 0;
 
   /*
+   * returns the number of demuxer bytes in any internal buffers
+   */
+  virtual int GetDataSize(void)
+  {
+    return 0;
+  }
+
+  /*
    * will be called by video player indicating the playback speed. see DVD_PLAYSPEED_NORMAL,
    * DVD_PLAYSPEED_PAUSE and friends.
    */
diff -Naur kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecHisi.cpp kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecHisi.cpp
--- kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecHisi.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecHisi.cpp	2016-04-11 09:45:33.293020491 +0200
@@ -0,0 +1,191 @@
+
+/*
+ *      Copyright (C) 2005-2011 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "DVDVideoCodecHisi.h"
+#include "HisiVideoCodec.h"
+#include "DVDClock.h"
+#include "video/VideoThumbLoader.h"
+#include "utils/log.h"
+
+#define __MODULE_NAME__ "DVDVideoCodecHisi"
+
+
+CDVDVideoCodecHisi::CDVDVideoCodecHisi() :
+  m_Codec(NULL),
+  m_pFormatName("HisiVideo")
+{
+}
+
+CDVDVideoCodecHisi::~CDVDVideoCodecHisi()
+{
+  Dispose();
+}
+
+bool CDVDVideoCodecHisi::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
+{
+  switch (hints.codec)
+  {
+  case AV_CODEC_ID_MPEG1VIDEO: //1
+  case AV_CODEC_ID_MPEG2VIDEO: //2
+  case AV_CODEC_ID_MPEG2VIDEO_XVMC: //3
+    m_pFormatName = "hisi-mpeg2";
+    break;
+  case AV_CODEC_ID_H263: //5
+  case AV_CODEC_ID_H263P: //20
+  case AV_CODEC_ID_H263I: //21
+	m_pFormatName = "hisi-h263";
+	break;
+  case AV_CODEC_ID_RV10: //6
+  case AV_CODEC_ID_RV20: //7
+  case AV_CODEC_ID_RV30: //70 = 0x46u?
+  case AV_CODEC_ID_RV40: //71 = 0x47u?
+	m_pFormatName = "hisi-rv";
+    break;
+  case AV_CODEC_ID_MPEG4: //13
+  case AV_CODEC_ID_MSMPEG4V2: //16
+  case AV_CODEC_ID_MSMPEG4V3: //17
+	m_pFormatName = "hisi-mpeg4";
+    break;
+  case AV_CODEC_ID_FLV1: //22 = 0x16u
+	m_pFormatName = "hisi-flv1";
+    break;
+  case AV_CODEC_ID_H264: //28 = 0x1Cu
+    m_pFormatName = "hisi-h264";
+    break;
+  case AV_CODEC_ID_VC1: //0x48u
+    m_pFormatName = "hisi-vc1";
+    break;
+  case AV_CODEC_ID_WMV3: //0x49u
+    m_pFormatName = "hisi-wmv3";
+    break;
+
+  default:
+    CLog::Log(LOGERROR, "Codec not supported codec = 0x%x", hints.codec);
+    return false;
+  }
+
+  m_hints = hints;
+
+  m_Codec = new CHisiVideoCodec();
+  if (!m_Codec)
+  {
+    CLog::Log(LOGERROR, "%s: Failed to create Hisi VideoCodec", __MODULE_NAME__);
+    return false;
+  }
+
+  m_opened = false;
+
+  memset(&m_videobuffer, 0, sizeof(DVDVideoPicture));
+
+  m_videobuffer.color_range  = 0;
+  m_videobuffer.color_matrix = 4;
+  m_videobuffer.dts/*24*/ = DVD_NOPTS_VALUE;
+  m_videobuffer.pts/*16*/ = DVD_NOPTS_VALUE;
+  m_videobuffer.format/*140*/ = RENDER_FMT_BYPASS; //RENDER_FMT_OMXEGL; //spitzbube: TODO
+  m_videobuffer.iFlags/*64*/  = DVP_FLAG_ALLOCATED;
+  m_videobuffer.iWidth/*124*/  = hints.width;
+  m_videobuffer.iHeight/*128*/ = hints.height;
+  m_videobuffer.iDisplayWidth/*132*/  = m_videobuffer.iWidth;
+  m_videobuffer.iDisplayHeight/*136*/ = m_videobuffer.iHeight;
+
+#if 1 //Spitzbube: TODO
+  CJobManager::GetInstance().PauseJobs();//CJobManager::GetInstance().Pause(kJobTypeMediaFlags);
+  if (CJobManager::GetInstance().IsProcessing(kJobTypeMediaFlags) > 0)
+  {
+    int timeout_ms = 5000;
+    // use m_bStop and Sleep so we can get canceled.
+    while (timeout_ms > 0)
+    {
+      if (CJobManager::GetInstance().IsProcessing(kJobTypeMediaFlags) > 0)
+      {
+        Sleep(100);
+        timeout_ms -= 100;
+      }
+      else
+        break;
+    }
+  }
+#endif
+
+  if (!m_opened)
+  {
+    if (m_Codec && !m_Codec->OpenDecoder(m_hints))
+      CLog::Log(LOGERROR, "%s: Failed to open Hisi Video Codec", __MODULE_NAME__);
+    m_opened = true;
+  }
+
+  CLog::Log(LOGINFO, "%s: Opened Hisi VideoCodec", __MODULE_NAME__);
+
+  return true;
+}
+
+void CDVDVideoCodecHisi::Dispose()
+{
+  if (m_Codec)
+    m_Codec->CloseDecoder(), delete m_Codec, m_Codec = NULL;
+
+  if (m_videobuffer.iFlags)
+    m_videobuffer.iFlags = 0;
+
+#if 1 //Spitzbube: TODO
+  // let thumbgen jobs resume.
+  CJobManager::GetInstance().UnPauseJobs(); //CJobManager::GetInstance().UnPause(kJobTypeMediaFlags);
+#endif
+}
+
+void CDVDVideoCodecHisi::Reset()
+{
+  m_Codec->Reset();
+}
+
+int CDVDVideoCodecHisi::Decode(uint8_t* pData, int iSize, double dts, double pts)
+{
+  return m_Codec->Decode(pData, iSize, dts, pts);
+}
+
+bool CDVDVideoCodecHisi::GetPicture(DVDVideoPicture* pDvdVideoPicture)
+{
+  m_Codec->GetPicture(&m_videobuffer);
+  *pDvdVideoPicture = m_videobuffer;
+
+  return true;
+}
+
+void CDVDVideoCodecHisi::SetDropState(bool bDrop)
+{
+}
+
+void CDVDVideoCodecHisi::SetSpeed(int speed)
+{
+  m_Codec->SetSpeed(speed);
+}
+
+int CDVDVideoCodecHisi::GetDataSize(void)
+{
+  return m_Codec->GetDataSize();
+}
+
+double CDVDVideoCodecHisi::GetTimeSize(void)
+{
+  return m_Codec->GetTimeSize();
+}
+
diff -Naur kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecHisi.h kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecHisi.h
--- kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecHisi.h	1970-01-01 01:00:00.000000000 +0100
+++ kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecHisi.h	2016-04-11 09:46:21.785021650 +0200
@@ -0,0 +1,58 @@
+
+#pragma once
+/*
+ *      Copyright (C) 2005-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "DVDVideoCodec.h"
+#include "DVDStreamInfo.h"
+
+
+class CHisiVideoCodec;
+
+
+class CDVDVideoCodecHisi : public CDVDVideoCodec
+{
+public:
+
+  CDVDVideoCodecHisi();
+  virtual ~CDVDVideoCodecHisi();
+
+  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
+  virtual void Dispose();
+  virtual int Decode(uint8_t* pData, int iSize, double dts, double pts);
+  virtual void Reset();
+  virtual bool GetPicture(DVDVideoPicture* pDvdVideoPicture);
+  virtual const char* GetName() { return m_pFormatName; }
+  virtual void SetDropState(bool bDrop);
+  virtual void SetSpeed(int iSpeed);
+  virtual int  GetDataSize(void);
+  virtual double GetTimeSize(void);
+
+protected:
+
+  CHisiVideoCodec *m_Codec; //4
+  const char     *m_pFormatName; //8
+  DVDVideoPicture m_videobuffer; //16
+  bool            m_opened; //144
+  CDVDStreamInfo  m_hints; //148
+
+};
+
diff -Naur kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Video/HisiVideoCodec.cpp kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Video/HisiVideoCodec.cpp
--- kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Video/HisiVideoCodec.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Video/HisiVideoCodec.cpp	2016-04-16 20:13:38.008394841 +0200
@@ -0,0 +1,2810 @@
+/*
+ *      Copyright (C) 2005-2011 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "HisiVideoCodec.h"
+#include "DllLibHiComm.h"
+#include "DllLibHiMpi.h"
+#include "DllLibHiSample.h"
+#include "Application.h"
+#include "cores/dvdplayer/DVDClock.h"
+#include "guilib/GraphicContext.h"
+#include "settings/DisplaySettings.h"
+#include "settings/MediaSettings.h"
+#include "utils/log.h"
+#include "utils/StringUtils.h"
+#include "cores/VideoRenderers/RenderManager.h"
+
+#define PTS_FREQ         1000000 //90000
+#define PTS_FREQ_MS	  1000 //90
+#define UNIT_FREQ       96000
+#define RW_WAIT_TIME    (20 * 1000) // 20ms
+
+// same as AV_NOPTS_VALUE
+#define INT64_0         INT64_C(0x8000000000000000)
+
+#define EXTERNAL_PTS    (1)
+#define SYNC_OUTSIDE    (2)
+
+#if 1 //tools/depends/target/libamplayer/libamplayer/include/amcodec/amports/vformat.h
+typedef enum {
+    VIDEO_DEC_FORMAT_UNKNOW,
+    VIDEO_DEC_FORMAT_MPEG4_3,
+    VIDEO_DEC_FORMAT_MPEG4_4,
+    VIDEO_DEC_FORMAT_MPEG4_5,
+    VIDEO_DEC_FORMAT_H264,
+    VIDEO_DEC_FORMAT_MJPEG,
+    VIDEO_DEC_FORMAT_MP4,
+    VIDEO_DEC_FORMAT_H263,
+    VIDEO_DEC_FORMAT_REAL_8,
+    VIDEO_DEC_FORMAT_REAL_9,
+    VIDEO_DEC_FORMAT_WMV3,
+    VIDEO_DEC_FORMAT_WVC1,
+    VIDEO_DEC_FORMAT_SW,
+    VIDEO_DEC_FORMAT_AVS,
+    VIDEO_DEC_FORMAT_MAX
+} vdec_type_t;
+
+typedef enum {
+    VFORMAT_UNKNOWN = -1,
+    VFORMAT_MPEG12 = 0,
+    VFORMAT_MPEG4, //1
+    VFORMAT_H264, //2
+    VFORMAT_MJPEG, //3
+    VFORMAT_REAL, //4
+    VFORMAT_JPEG,
+    VFORMAT_VC1, //6
+    VFORMAT_AVS,
+    VFORMAT_SW,
+    VFORMAT_H264MVC,
+    VFORMAT_UNSUPPORT, //10
+    VFORMAT_MAX
+} vformat_t;
+
+#define CODEC_TAG_MJPEG     (0x47504a4d)
+#define CODEC_TAG_mjpeg     (0x47504a4c)
+#define CODEC_TAG_jpeg      (0x6765706a)
+#define CODEC_TAG_mjpa      (0x61706a6d)
+#define CODEC_TAG_XVID      (0x44495658)
+#define CODEC_TAG_xvid      (0x64697678)
+#define CODEC_TAG_XVIX      (0x58495658)
+#define CODEC_TAG_xvix      (0x78697678)
+#define CODEC_TAG_MP4       (0x8e22ada)
+#define CODEC_TAG_COL1      (0x314c4f43)
+#define CODEC_TAG_DIV3      (0x33564944)
+#define CODEC_TAG_MP43      (0x3334504d)
+#define CODEC_TAG_M4S2      (0x3253344d)
+#define CODEC_TAG_DIV4      (0x34564944)
+#define CODEC_TAG_DIVX      (0x58564944)
+#define CODEC_TAG_DIV5      (0x35564944)
+#define CODEC_TAG_DX50      (0x30355844)
+#define CODEC_TAG_DIV6      (0x36564944)
+#define CODEC_TAG_RMP4      (0x34504d52)
+#define CODEC_TAG_MP42      (0x3234504d)
+#define CODEC_TAG_MPG4      (0x3447504d)
+#define CODEC_TAG_MP4V      (0x5634504d)
+#define CODEC_TAG_mp4v      (0x7634706d)
+#define CODEC_TAG_AVC1      (0x31435641)
+#define CODEC_TAG_avc1      (0x31637661)
+#define CODEC_TAG_H264      (0x34363248)
+#define CODEC_TAG_h264      (0x34363268)
+#define CODEC_TAG_H263      (0x33363248)
+#define CODEC_TAG_h263      (0x33363268)
+#define CODEC_TAG_s263      (0x33363273)
+#define CODEC_TAG_F263      (0x33363246)
+#define CODEC_TAG_WMV1      (0x31564d57)
+#define CODEC_TAG_WMV2      (0x32564d57)
+#define CODEC_TAG_WMV3      (0x33564d57)
+#define CODEC_TAG_WVC1      (0x31435657)
+#define CODEC_TAG_WMVA      (0x41564d57)
+#define CODEC_TAG_FMP4      (0x34504d46)
+#define CODEC_TAG_VC_1  (0x312D4356)
+#define CODEC_TAG_RV30  (0x30335652)
+#define CODEC_TAG_RV40  (0x30345652)
+#endif //tools/depends/target/libamplayer/libamplayer/include/amcodec/amports/vformat.h
+
+#define P_PRE           (0x02000000)
+#define F_PRE           (0x03000000)
+#define PLAYER_SUCCESS          (0)
+#define PLAYER_FAILED           (-(P_PRE|0x01))
+#define PLAYER_NOMEM            (-(P_PRE|0x02))
+#define PLAYER_EMPTY_P          (-(P_PRE|0x03))
+
+#define PLAYER_WR_FAILED        (-(P_PRE|0x21))
+#define PLAYER_WR_EMPTYP        (-(P_PRE|0x22))
+#define PLAYER_WR_FINISH        (P_PRE|0x1)
+
+#define PLAYER_PTS_ERROR        (-(P_PRE|0x31))
+#define PLAYER_UNSUPPORT        (-(P_PRE|0x35))
+#define PLAYER_CHECK_CODEC_ERROR  (-(P_PRE|0x39))
+
+#define HDR_BUF_SIZE 1024
+typedef struct hdr_buf {
+    char *data;
+    int size;
+} hdr_buf_t;
+
+typedef struct hisi_packet {
+    AVPacket      avpkt; //0
+    double          avpts; //72
+    double          avdts; //80
+    int                avduration; //88
+    int                isvalid; //92
+    int                newflag; //96
+    double          lastpts; //104
+    unsigned char *data; //112
+    unsigned char *buf; //116
+    int                data_size; //120
+    int                buf_size; //124
+    hdr_buf_t     *hdr; //128
+    codec_para_t  *codec; //132
+} hisi_packet_t;
+
+typedef enum {
+    HISI_STREAM_UNKNOWN = 0,
+    HISI_STREAM_TS,
+    HISI_STREAM_PS,
+    HISI_STREAM_ES, //3
+    HISI_STREAM_RM,
+    HISI_STREAM_AUDIO,
+    HISI_STREAM_VIDEO,
+} pstream_type;
+
+typedef union {
+    int64_t      total_bytes;
+    unsigned int vpkt_num;
+    unsigned int spkt_num;
+} read_write_size;
+
+typedef  struct {
+    unsigned int read_end_flag: 1; //4380
+    unsigned int end_flag: 1;
+    unsigned int reset_flag: 1;
+    int check_lowlevel_eagain_cnt; //4384
+} p_ctrl_info_t;
+
+typedef struct hisi_private_t
+{
+  hisi_packet_t    hisi_pkt; //0
+#if 1
+  codec_para_t vcodec; //136
+#else
+  int Data_136; //136
+#endif
+  int fill_140[22]; //140
+  int Data_228; //228 -> vcodec.hisi_sysinfo.param
+  int fill_232[24]; //232
+  int Data_328; //328
+  int Data_332; //332
+  int fill_336[1010]; //336
+
+  pstream_type stream_type; //4376
+  p_ctrl_info_t     playctrl_info; //4380
+  read_write_size   read_size; //4392
+  read_write_size   write_size; //4400
+  int check_first_pts; //4408
+  vformat_t video_format; //4412
+  int video_pid; //4416
+  int video_codec_id; //4420
+  int video_codec_tag; //4424
+  vdec_type_t video_codec_type; //4428
+  int video_width; //4432
+  int video_height; //4436
+  int fill_4440[2]; //4440
+  int video_rate; //4448
+  int video_rotation_degree; //4452
+  int flv_flag; //4456
+  int fill_4460; //4460
+  int extrasize; //4464
+  uint8_t* extradata; //4468
+  DllLibHiSample* m_dll_sample; //4472
+  DllLibHiComm* m_dll_comm; //4476
+  DllLibHiMpi* m_dll_mpi; //4480
+  HI_HANDLE m_hAvplay; //4484
+  HI_HANDLE m_hWin; //4488
+  bool m_preloading_done; //4492
+  //0x1190 = 4496
+} hisi_private_t;
+
+struct buf_status {
+    int size;
+    int data_len;
+    int free_len;
+    unsigned int read_pointer;
+    unsigned int write_pointer;
+};
+
+
+//HI_HANDLE CHisiVideoCodec::g_m_hAvplay = 0;
+unsigned int g_m_hAvplay = 0;
+
+extern double g_m_hvsync;
+//extern double g_m_hasync;
+extern double g_m_hvwait;
+
+
+static vdec_type_t codec_tag_to_vdec_type(unsigned int codec_tag)
+{
+  vdec_type_t dec_type;
+  switch (codec_tag)
+  {
+    case CODEC_TAG_XVID:
+    case CODEC_TAG_xvid:
+    case CODEC_TAG_XVIX:
+      dec_type = VIDEO_DEC_FORMAT_MPEG4_5;
+      break;
+    case CODEC_TAG_COL1:
+    case CODEC_TAG_DIV3:
+    case CODEC_TAG_MP43:
+      dec_type = VIDEO_DEC_FORMAT_MPEG4_3;
+      break;
+    case CODEC_TAG_DIV4:
+    case CODEC_TAG_DIVX:
+      dec_type = VIDEO_DEC_FORMAT_MPEG4_4;
+      break;
+    case CODEC_TAG_DIV5:
+    case CODEC_TAG_DX50:
+    case CODEC_TAG_M4S2:
+    case CODEC_TAG_FMP4:
+      dec_type = VIDEO_DEC_FORMAT_MPEG4_5;
+      break;
+    case CODEC_TAG_DIV6:
+      dec_type = VIDEO_DEC_FORMAT_MPEG4_5;
+      break;
+    case CODEC_TAG_MP4V:
+    case CODEC_TAG_RMP4:
+    case CODEC_TAG_MPG4:
+    case CODEC_TAG_mp4v:
+    case AV_CODEC_ID_MPEG4:
+      dec_type = VIDEO_DEC_FORMAT_MPEG4_5;
+      break;
+    case AV_CODEC_ID_H263:
+    case CODEC_TAG_H263:
+    case CODEC_TAG_h263:
+    case CODEC_TAG_s263:
+    case CODEC_TAG_F263:
+      dec_type = VIDEO_DEC_FORMAT_H263;
+      break;
+    case CODEC_TAG_AVC1:
+    case CODEC_TAG_avc1:
+    case CODEC_TAG_H264:
+    case CODEC_TAG_h264:
+      dec_type = VIDEO_DEC_FORMAT_H264;
+      break;
+    case AV_CODEC_ID_RV30:
+    case CODEC_TAG_RV30:
+      dec_type = VIDEO_DEC_FORMAT_REAL_8;
+      break;
+    case AV_CODEC_ID_RV40:
+    case CODEC_TAG_RV40:
+      dec_type = VIDEO_DEC_FORMAT_REAL_9;
+      break;
+    case AV_CODEC_ID_H264:
+      dec_type = VIDEO_DEC_FORMAT_H264;
+      break;
+    /*
+    case AV_CODEC_ID_H264MVC:
+      dec_type = VIDEO_DEC_FORMAT_H264;
+      break;
+    */
+    case CODEC_TAG_WMV3:
+      dec_type = VIDEO_DEC_FORMAT_WMV3;
+      break;
+    case AV_CODEC_ID_VC1:
+    case CODEC_TAG_VC_1:
+    case CODEC_TAG_WVC1:
+    case CODEC_TAG_WMVA:
+      dec_type = VIDEO_DEC_FORMAT_WVC1;
+      break;
+    case AV_CODEC_ID_VP6F:
+      dec_type = VIDEO_DEC_FORMAT_SW;
+      break;
+    default:
+      dec_type = VIDEO_DEC_FORMAT_UNKNOW;
+      break;
+  }
+
+  CLog::Log(LOGDEBUG, "codec_tag_to_vdec_type, codec_tag(%d) -> vdec_type(%d)", codec_tag, dec_type);
+  return dec_type;
+}
+
+static void hisi_packet_init(hisi_packet_t *pkt)
+{
+  memset(&pkt->avpkt, 0, sizeof(AVPacket));
+  pkt->avpts      = 0;
+  pkt->avdts      = 0;
+  pkt->avduration = 0;
+  pkt->isvalid    = 0;
+  pkt->newflag    = 0;
+  pkt->lastpts    = 0;
+  pkt->data       = NULL;
+  pkt->buf        = NULL;
+  pkt->data_size  = 0;
+  pkt->buf_size   = 0;
+  pkt->hdr        = NULL;
+  pkt->codec      = NULL;
+}
+
+static void hisi_packet_release(hisi_packet_t *pkt)
+{
+  if (pkt->buf != NULL)
+  {
+    free(pkt->buf);
+    pkt->buf= NULL;
+  }
+  if (pkt->hdr != NULL)
+  {
+    free(pkt->hdr->data);
+    pkt->hdr->data = NULL;
+    free(pkt->hdr);
+    pkt->hdr = NULL;
+  }
+  pkt->codec = NULL;
+}
+
+static int check_in_pts(hisi_private_t *para, hisi_packet_t *pkt)
+{
+    int last_duration = 0;
+    static int last_v_duration = 0;
+    double pts = 0;
+
+    last_duration = last_v_duration;
+
+    if (para->stream_type == HISI_STREAM_ES) {
+        if ((double)AV_NOPTS_VALUE != pkt->avpts) {
+            pts = pkt->avpts;
+/*
+            if (para->m_dll->codec_checkin_pts(pkt->codec, pts) != 0) {
+                CLog::Log(LOGDEBUG, "ERROR check in pts error!");
+                return PLAYER_PTS_ERROR;
+            }
+*/
+
+        } else if ((double)AV_NOPTS_VALUE != pkt->avdts) {
+            pts = pkt->avdts * last_duration;
+/*
+            if (para->m_dll->codec_checkin_pts(pkt->codec, pts) != 0) {
+                CLog::Log(LOGDEBUG, "ERROR check in dts error!");
+                return PLAYER_PTS_ERROR;
+            }
+*/
+            last_v_duration = pkt->avduration ? pkt->avduration : 1;
+        } else {
+            if (!para->check_first_pts) {
+		/*
+                if (para->m_dll->codec_checkin_pts(pkt->codec, 0) != 0) {
+                    CLog::Log(LOGDEBUG, "ERROR check in 0 to video pts error!");
+                    return PLAYER_PTS_ERROR;
+                }
+                */
+            }
+        }
+        if (!para->check_first_pts) {
+            para->check_first_pts = 1;
+        }
+    }
+    if (pts > 0)
+      pkt->lastpts = pts;
+
+//CLog::Log(LOGDEBUG, "lastpts: (%f)(%f)(%f)(%f)", pkt->lastpts, pts, pkt->avpts, pkt->avdts);
+    return PLAYER_SUCCESS;
+}
+
+static int check_write_finish(hisi_private_t *para, hisi_packet_t *pkt)
+{
+    if (para->playctrl_info.read_end_flag) {
+        //6b2508
+        if ((para->write_size.vpkt_num == para->read_size.vpkt_num)) {
+            return PLAYER_WR_FINISH;
+        }
+    }
+    return PLAYER_WR_FAILED;
+}
+
+static int write_header(hisi_private_t *para, hisi_packet_t *pkt)
+{
+    int write_bytes = 0, len = 0;
+
+//CLog::Log(LOGDEBUG, "write_header 1");
+
+    if (pkt->hdr && pkt->hdr->size > 0) {
+        if ((NULL == pkt->codec) || (NULL == pkt->hdr->data)) {
+            CLog::Log(LOGDEBUG, "[write_header]codec null!");
+            return PLAYER_EMPTY_P;
+        }
+        while (1) {
+            HI_S32 Ret;
+            HI_UNF_STREAM_BUF_S StreamBuf;
+            HI_U32 u32PtsMs;
+
+//CLog::Log(LOGDEBUG, "write_header 2, size 0x%x", pkt->hdr->size - len);
+            Ret = para->m_dll_mpi->HI_UNF_AVPLAY_GetBuf(para->m_hAvplay, HI_UNF_AVPLAY_BUF_ID_ES_VID, pkt->hdr->size - len, &StreamBuf, 0);
+            if (HI_SUCCESS == Ret)
+            {
+//CLog::Log(LOGDEBUG, "write_header 3, size 0x%x", pkt->hdr->size - len);
+                memcpy((char *)StreamBuf.pu8Data, pkt->hdr->data + len, pkt->hdr->size - len);
+
+                if ((double)AV_NOPTS_VALUE != pkt->avpts)
+                  u32PtsMs = (HI_U32)(pkt->avpts/PTS_FREQ_MS);
+	         else
+                  u32PtsMs = (HI_U32)(pkt->avdts/PTS_FREQ_MS);
+
+                Ret = para->m_dll_mpi->HI_UNF_AVPLAY_PutBuf(para->m_hAvplay, HI_UNF_AVPLAY_BUF_ID_ES_VID, pkt->hdr->size - len, u32PtsMs);
+                if (HI_SUCCESS == Ret)
+                {
+                   write_bytes = pkt->hdr->size - len;
+                }
+                else
+	         {
+CLog::Log(LOGDEBUG, "write_header 4, Ret 0x%x", Ret);
+        	    write_bytes = -1;
+	         }
+            }
+	     else
+	     {
+CLog::Log(LOGDEBUG, "write_header 5, Ret 0x%x", Ret);
+        	  write_bytes = -1;
+	     }
+
+            //write_bytes = para->m_dll->codec_write(pkt->codec, pkt->hdr->data + len, pkt->hdr->size - len);
+            if (write_bytes < 0 || write_bytes > (pkt->hdr->size - len)) {
+                //if (-errno != AVERROR(EAGAIN)) {
+                //    CLog::Log(LOGDEBUG, "ERROR:write header failed!");
+                //    return PLAYER_WR_FAILED;
+                //} else {
+                //    continue;
+                //}
+                return PLAYER_SUCCESS;
+            } else {
+                len += write_bytes;
+                if (len == pkt->hdr->size) {
+                    break;
+                }
+            }
+        }
+    }
+
+    return PLAYER_SUCCESS;
+}
+
+static int check_avbuffer_enough(hisi_private_t *para, hisi_packet_t *pkt)
+{
+    return 1;
+}
+
+static int write_v_packet(hisi_private_t *para, hisi_packet_t *pkt)
+{
+  //CLog::Log(LOGDEBUG, "write_v_packet, pkt->isvalid(%d), pkt->data(%p), pkt->data_size(%d)",
+  //  pkt->isvalid, pkt->data, pkt->data_size);
+
+    int write_bytes = 0, len = 0, ret;
+    unsigned char *buf;
+    int size, wsize;
+
+//CLog::Log(LOGDEBUG, "write_v_packet 1");
+    if (pkt->newflag) {
+        if (pkt->isvalid) {
+            ret = check_in_pts(para, pkt);
+            if (ret != PLAYER_SUCCESS) {
+                CLog::Log(LOGDEBUG, "check in pts failed");
+                return PLAYER_WR_FAILED;
+            }
+        }
+//CLog::Log(LOGDEBUG, "write_v_packet 2");
+        if (write_header(para, pkt) == PLAYER_WR_FAILED) {
+            CLog::Log(LOGDEBUG, "[%s]write header failed!", __FUNCTION__);
+            return PLAYER_WR_FAILED;
+        }
+        pkt->newflag = 0;
+    }
+
+    buf = pkt->data;
+    size = pkt->data_size ;
+    if (size == 0 && pkt->isvalid) {
+    	//6b24e4
+        para->write_size.vpkt_num++;
+        pkt->isvalid = 0;
+    }
+    while (size > 0 && pkt->isvalid) {
+        HI_S32 Ret;
+        HI_UNF_STREAM_BUF_S StreamBuf;
+        HI_U32 u32PtsMs;
+	 int Retry;
+
+        wsize = size;
+//CLog::Log(LOGDEBUG, "write_v_packet 3, size 0x%x", wsize);
+        for(Retry = 0; Retry < 10; Retry++)
+        {
+        Ret = para->m_dll_mpi->HI_UNF_AVPLAY_GetBuf(para->m_hAvplay, HI_UNF_AVPLAY_BUF_ID_ES_VID, wsize, &StreamBuf, 0);
+        if (HI_SUCCESS == Ret)
+        {
+//CLog::Log(LOGDEBUG, "vpts %d", pkt->avpts);
+            memcpy((char *)StreamBuf.pu8Data, buf, wsize);
+
+#if 0 //Spitzbube: TODO
+            if ((double)AV_NOPTS_VALUE != pkt->avpts)
+              u32PtsMs = (HI_U32)(pkt->avpts/PTS_FREQ_MS);
+	        else
+              u32PtsMs = (HI_U32)(pkt->avdts/PTS_FREQ_MS);
+#else
+            u32PtsMs = 0;
+#endif
+
+            Ret = para->m_dll_mpi->HI_UNF_AVPLAY_PutBuf(para->m_hAvplay, HI_UNF_AVPLAY_BUF_ID_ES_VID, wsize, u32PtsMs);
+            if (HI_SUCCESS == Ret)
+            {
+                write_bytes = wsize;
+            }
+            else
+            {
+		CLog::Log(LOGDEBUG, "write_v_packet 5, ret 0x%x", Ret);
+        	  write_bytes = -1;
+            }
+	     break;
+        }
+	 else
+ 	 {
+CLog::Log(LOGDEBUG, "write_v_packet 4, ret 0x%x", Ret);
+        	write_bytes = -1;
+	     usleep(RW_WAIT_TIME*10);
+ 	 }
+ 	 }
+        //write_bytes = para->m_dll->codec_write(pkt->codec, (char *)buf, size);
+        if (write_bytes < 0 || write_bytes > size) {
+            if (0 /*-errno != AVERROR(EAGAIN)*/) {
+                para->playctrl_info.check_lowlevel_eagain_cnt = 0;
+                CLog::Log(LOGDEBUG, "write codec data failed!");
+                return PLAYER_WR_FAILED;
+            } else {
+                // EAGAIN to see if buffer full or write time out too much
+                if (check_avbuffer_enough(para, pkt)) {
+                  para->playctrl_info.check_lowlevel_eagain_cnt++;
+                } else {
+                  para->playctrl_info.check_lowlevel_eagain_cnt = 0;
+                }
+
+                if (para->playctrl_info.check_lowlevel_eagain_cnt > 50) {
+                    // reset decoder
+                    para->playctrl_info.check_lowlevel_eagain_cnt = 0;
+                    para->playctrl_info.reset_flag = 1;
+                    para->playctrl_info.end_flag = 1;
+                    CLog::Log(LOGDEBUG, "$$$$$$ write blocked, need reset decoder!$$$$$$");
+                }
+                //pkt->data += len;
+                //pkt->data_size -= len;
+                usleep(RW_WAIT_TIME);
+                CLog::Log(LOGDEBUG, "usleep(RW_WAIT_TIME), len(%d)", len);
+                return PLAYER_SUCCESS;
+            }
+        }
+	 else {
+		 //6b2894
+            para->playctrl_info.check_lowlevel_eagain_cnt = 0;
+            len += write_bytes;
+            if (len == pkt->data_size) {
+                para->write_size.vpkt_num++;
+                pkt->isvalid = 0;
+                pkt->data_size = 0;
+                break;
+            } else if (len < pkt->data_size) {
+                buf += write_bytes;
+                size -= write_bytes;
+            } else {
+                return PLAYER_WR_FAILED;
+            }
+        }
+    }
+    //6b24f8
+    if (check_write_finish(para, pkt) == PLAYER_WR_FINISH) {
+        return PLAYER_WR_FINISH;
+    }
+
+    return PLAYER_SUCCESS;
+}
+
+static int check_size_in_buffer(unsigned char *p, int len)
+{
+    unsigned int size;
+    unsigned char *q = p;
+    while ((q + 4) < (p + len)) {
+        size = (*q << 24) | (*(q + 1) << 16) | (*(q + 2) << 8) | (*(q + 3));
+        if (size & 0xff000000) {
+            return 0;
+        }
+
+        if (q + size + 4 == p + len) {
+            return 1;
+        }
+
+        q += size + 4;
+    }
+    return 0;
+}
+
+static int check_size_in_buffer3(unsigned char *p, int len)
+{
+    unsigned int size;
+    unsigned char *q = p;
+    while ((q + 3) < (p + len)) {
+        size = (*q << 16) | (*(q + 1) << 8) | (*(q + 2));
+
+        if (q + size + 3 == p + len) {
+            return 1;
+        }
+
+        q += size + 3;
+    }
+    return 0;
+}
+
+static int check_size_in_buffer2(unsigned char *p, int len)
+{
+    unsigned int size;
+    unsigned char *q = p;
+    while ((q + 2) < (p + len)) {
+        size = (*q << 8) | (*(q + 1));
+
+        if (q + size + 2 == p + len) {
+            return 1;
+        }
+
+        q += size + 2;
+    }
+    return 0;
+}
+
+static int m4s2_dx50_mp4v_add_header(unsigned char *buf, int size,  hisi_packet_t *pkt)
+{
+    if (size > pkt->hdr->size) {
+        free(pkt->hdr->data), pkt->hdr->data = NULL;
+        pkt->hdr->size = 0;
+
+        pkt->hdr->data = (char*)malloc(size);
+        if (!pkt->hdr->data) {
+            CLog::Log(LOGDEBUG, "[m4s2_dx50_add_header] NOMEM!");
+            return PLAYER_FAILED;
+        }
+    }
+
+    pkt->hdr->size = size;
+    memcpy(pkt->hdr->data, buf, size);
+
+    return PLAYER_SUCCESS;
+}
+
+static int m4s2_dx50_mp4v_write_header(hisi_private_t *para, hisi_packet_t *pkt)
+{
+    CLog::Log(LOGDEBUG, "m4s2_dx50_mp4v_write_header");
+    int ret = m4s2_dx50_mp4v_add_header(para->extradata, para->extrasize, pkt);
+    if (ret == PLAYER_SUCCESS) {
+        if (1) {
+            pkt->codec = &para->vcodec;
+        } else {
+            CLog::Log(LOGDEBUG, "[m4s2_dx50_mp4v_add_header]invalid video codec!");
+            return PLAYER_EMPTY_P;
+        }
+        pkt->newflag = 1;
+        ret = write_v_packet(para, pkt);
+    }
+    return ret;
+}
+
+static int divx3_data_prefeeding(hisi_packet_t *pkt, unsigned w, unsigned h)
+{
+    unsigned i = (w << 12) | (h & 0xfff);
+    unsigned char divx311_add[10] = {
+        0x00, 0x00, 0x00, 0x01,
+        0x20, 0x00, 0x00, 0x00,
+        0x00, 0x00
+    };
+    divx311_add[5] = (i >> 16) & 0xff;
+    divx311_add[6] = (i >> 8) & 0xff;
+    divx311_add[7] = i & 0xff;
+
+    if (pkt->hdr->data) {
+        memcpy(pkt->hdr->data, divx311_add, sizeof(divx311_add));
+        pkt->hdr->size = sizeof(divx311_add);
+    } else {
+        CLog::Log(LOGDEBUG, "[divx3_data_prefeeding]No enough memory!");
+        return PLAYER_FAILED;
+    }
+    return PLAYER_SUCCESS;
+}
+
+static int divx3_write_header(hisi_private_t *para, hisi_packet_t *pkt)
+{
+    CLog::Log(LOGDEBUG, "divx3_write_header");
+    divx3_data_prefeeding(pkt, para->video_width, para->video_height);
+    if (1) {
+        pkt->codec = &para->vcodec;
+    } else {
+        CLog::Log(LOGDEBUG, "[divx3_write_header]invalid codec!");
+        return PLAYER_EMPTY_P;
+    }
+    pkt->newflag = 1;
+    write_v_packet(para, pkt);
+    return PLAYER_SUCCESS;
+}
+
+static int h264_add_header(unsigned char *buf, int size, hisi_packet_t *pkt)
+{
+    char nal_start_code[] = {0x0, 0x0, 0x0, 0x1};
+    int nalsize;
+    unsigned char* p;
+    int tmpi;
+    unsigned char* extradata = buf;
+    int header_len = 0;
+    char* buffer = pkt->hdr->data;
+
+    CLog::Log(LOGDEBUG, "[h264_add_header] 1(size %d)", size);
+    p = extradata;
+
+    // h264 annex-b
+	  if ((p[0]==0 && p[1]==0 && p[2]==0 && p[3]==1) && size < HDR_BUF_SIZE) {
+        CLog::Log(LOGDEBUG, "add 264 header in stream before header len=%d",size);
+        memcpy(buffer, buf, size);
+        pkt->hdr->size = size;
+    CLog::Log(LOGDEBUG, "[h264_add_header] 2");
+        return PLAYER_SUCCESS;
+    }
+
+    if (size < 4) {
+    CLog::Log(LOGDEBUG, "[h264_add_header] 3");
+        return PLAYER_FAILED;
+    }
+
+    if (size < 10) {
+        CLog::Log(LOGDEBUG, "avcC too short");
+        return PLAYER_FAILED;
+    }
+
+    // h264 avcC
+    if (*p != 1) {
+        CLog::Log(LOGDEBUG, "Unknown avcC version %d", *p);
+        return PLAYER_FAILED;
+    }
+
+    int cnt = *(p + 5) & 0x1f; //number of sps
+    // CLog::Log(LOGDEBUG, "number of sps :%d", cnt);
+    p += 6;
+    for (tmpi = 0; tmpi < cnt; tmpi++) {
+        nalsize = (*p << 8) | (*(p + 1));
+        memcpy(&(buffer[header_len]), nal_start_code, 4);
+        header_len += 4;
+        memcpy(&(buffer[header_len]), p + 2, nalsize);
+        header_len += nalsize;
+        p += (nalsize + 2);
+    }
+
+    cnt = *(p++); //Number of pps
+    // CLog::Log(LOGDEBUG, "number of pps :%d", cnt);
+    for (tmpi = 0; tmpi < cnt; tmpi++) {
+        nalsize = (*p << 8) | (*(p + 1));
+        memcpy(&(buffer[header_len]), nal_start_code, 4);
+        header_len += 4;
+        memcpy(&(buffer[header_len]), p + 2, nalsize);
+        header_len += nalsize;
+        p += (nalsize + 2);
+    }
+    if (header_len >= HDR_BUF_SIZE) {
+        CLog::Log(LOGDEBUG, "header_len %d is larger than max length", header_len);
+        return 0;
+    }
+
+    CLog::Log(LOGDEBUG, "==> exdata %02x %02x %02x %02x", buffer[4], buffer[5], buffer[6], buffer[7]);
+    if((buffer[4] == 0x67 && buffer[5] == 0x4D && buffer[6] == 0x40) || buffer[header_len - 1] == 0x80)
+    {
+	buffer[header_len - 1] = 0x30;
+
+       CLog::Log(LOGDEBUG, "==> header_len %d", header_len);
+       CLog::Log(LOGDEBUG, "==> exdata %02x %02x %02x %02x", buffer[header_len - 4], buffer[header_len - 3], buffer[header_len - 2], buffer[header_len - 1]);
+    }
+    pkt->hdr->size = header_len;
+
+    CLog::Log(LOGDEBUG, "[h264_add_header] 4");
+    return PLAYER_SUCCESS;
+}
+
+static int h264_write_header(hisi_private_t *para, hisi_packet_t *pkt)
+{
+    // CLog::Log(LOGDEBUG, "h264_write_header");
+    int ret = -1;
+
+    ret = h264_add_header(para->extradata, para->extrasize, pkt);
+    if (ret == PLAYER_SUCCESS) {
+        //if (ctx->vcodec) {
+        if (1) {
+            pkt->codec = &para->vcodec;
+        } else {
+            //CLog::Log(LOGDEBUG, "[pre_header_feeding]invalid video codec!");
+            return PLAYER_EMPTY_P;
+        }
+
+        pkt->newflag = 1;
+        ret = write_v_packet(para, pkt);
+    }
+    return ret;
+}
+
+static int wmv3_write_header(hisi_private_t *para, hisi_packet_t *pkt)
+{
+    CLog::Log(LOGDEBUG, "wmv3_write_header");
+    unsigned i, check_sum = 0;
+    unsigned data_len = para->extrasize + 4;
+
+    pkt->hdr->data[0] = 0;
+    pkt->hdr->data[1] = 0;
+    pkt->hdr->data[2] = 1;
+    pkt->hdr->data[3] = 0x10;
+
+    pkt->hdr->data[4] = 0;
+    pkt->hdr->data[5] = (data_len >> 16) & 0xff;
+    pkt->hdr->data[6] = 0x88;
+    pkt->hdr->data[7] = (data_len >> 8) & 0xff;
+    pkt->hdr->data[8] = data_len & 0xff;
+    pkt->hdr->data[9] = 0x88;
+
+    pkt->hdr->data[10] = 0xff;
+    pkt->hdr->data[11] = 0xff;
+    pkt->hdr->data[12] = 0x88;
+    pkt->hdr->data[13] = 0xff;
+    pkt->hdr->data[14] = 0xff;
+    pkt->hdr->data[15] = 0x88;
+
+    for (i = 4 ; i < 16 ; i++) {
+        check_sum += pkt->hdr->data[i];
+    }
+
+    pkt->hdr->data[16] = (check_sum >> 8) & 0xff;
+    pkt->hdr->data[17] =  check_sum & 0xff;
+    pkt->hdr->data[18] = 0x88;
+    pkt->hdr->data[19] = (check_sum >> 8) & 0xff;
+    pkt->hdr->data[20] =  check_sum & 0xff;
+    pkt->hdr->data[21] = 0x88;
+
+    pkt->hdr->data[22] = (para->video_width >> 8) & 0xff;
+    pkt->hdr->data[23] =  para->video_width & 0xff;
+    pkt->hdr->data[24] = (para->video_height >> 8) & 0xff;
+    pkt->hdr->data[25] =  para->video_height & 0xff;
+
+    memcpy(pkt->hdr->data + 26, para->extradata, para->extrasize);
+    pkt->hdr->size = para->extrasize + 26;
+    if (1) {
+        pkt->codec = &para->vcodec;
+    } else {
+        CLog::Log(LOGDEBUG, "[wmv3_write_header]invalid codec!");
+        return PLAYER_EMPTY_P;
+    }
+    pkt->newflag = 1;
+    return write_v_packet(para, pkt);
+}
+
+static int wvc1_write_header(hisi_private_t *para, hisi_packet_t *pkt)
+{
+    CLog::Log(LOGDEBUG, "wvc1_write_header");
+    memcpy(pkt->hdr->data, para->extradata + 1, para->extrasize - 1);
+    pkt->hdr->size = para->extrasize - 1;
+    if (1) {
+        pkt->codec = &para->vcodec;
+    } else {
+        CLog::Log(LOGDEBUG, "[wvc1_write_header]invalid codec!");
+        return PLAYER_EMPTY_P;
+    }
+    pkt->newflag = 1;
+    return write_v_packet(para, pkt);
+}
+
+static int mpeg_add_header(hisi_private_t *para, hisi_packet_t *pkt)
+{
+    CLog::Log(LOGDEBUG, "mpeg_add_header");
+#define STUFF_BYTES_LENGTH     (256)
+    int size;
+    unsigned char packet_wrapper[] = {
+        0x00, 0x00, 0x01, 0xe0,
+        0x00, 0x00,                                /* pes packet length */
+        0x81, 0xc0, 0x0d,
+        0x20, 0x00, 0x00, 0x00, 0x00, /* PTS */
+        0x1f, 0xff, 0xff, 0xff, 0xff, /* DTS */
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff
+    };
+
+    size = para->extrasize + sizeof(packet_wrapper);
+    packet_wrapper[4] = size >> 8 ;
+    packet_wrapper[5] = size & 0xff ;
+    memcpy(pkt->hdr->data, packet_wrapper, sizeof(packet_wrapper));
+    size = sizeof(packet_wrapper);
+    //CLog::Log(LOGDEBUG, "[mpeg_add_header:%d]wrapper size=%d\n",__LINE__,size);
+    memcpy(pkt->hdr->data + size, para->extradata, para->extrasize);
+    size += para->extrasize;
+    //CLog::Log(LOGDEBUG, "[mpeg_add_header:%d]wrapper+seq size=%d\n",__LINE__,size);
+    memset(pkt->hdr->data + size, 0xff, STUFF_BYTES_LENGTH);
+    size += STUFF_BYTES_LENGTH;
+    pkt->hdr->size = size;
+    //CLog::Log(LOGDEBUG, "[mpeg_add_header:%d]hdr_size=%d\n",__LINE__,size);
+    if (1) {
+        pkt->codec = &para->vcodec;
+    } else {
+        CLog::Log(LOGDEBUG, "[mpeg_add_header]invalid codec!");
+        return PLAYER_EMPTY_P;
+    }
+
+    pkt->newflag = 1;
+    return write_v_packet(para, pkt);
+}
+
+static int pre_v_header_feeding(hisi_private_t *para, hisi_packet_t *pkt)
+{
+    int ret;
+    if (para->stream_type == HISI_STREAM_ES) {
+	 CLog::Log(LOGDEBUG, "[pre_header_feeding] 1");
+        if (pkt->hdr == NULL) {
+            pkt->hdr = (hdr_buf_t*)malloc(sizeof(hdr_buf_t));
+            pkt->hdr->data = (char *)malloc(HDR_BUF_SIZE);
+            if (!pkt->hdr->data) {
+                //CLog::Log(LOGDEBUG, "[pre_header_feeding] NOMEM!");
+                return PLAYER_NOMEM;
+            }
+        }
+
+        if (VFORMAT_H264 == para->video_format /*|| VFORMAT_H264MVC == para->video_format*/) {
+	 CLog::Log(LOGDEBUG, "[pre_header_feeding] 2");
+	 /**/
+            ret = h264_write_header(para, pkt);
+            if (ret != PLAYER_SUCCESS) {
+                return ret;
+            }
+            /**/
+        } else if ((VFORMAT_MPEG4 == para->video_format) && (VIDEO_DEC_FORMAT_MPEG4_3 == para->video_codec_type)) {
+	 CLog::Log(LOGDEBUG, "[pre_header_feeding] 3");
+            ret = divx3_write_header(para, pkt);
+            if (ret != PLAYER_SUCCESS) {
+                return ret;
+            }
+        } else if ((CODEC_TAG_M4S2 == para->video_codec_tag)
+                || (CODEC_TAG_DX50 == para->video_codec_tag)
+                || (CODEC_TAG_mp4v == para->video_codec_tag)) {
+	 CLog::Log(LOGDEBUG, "[pre_header_feeding] 4");
+            ret = m4s2_dx50_mp4v_write_header(para, pkt);
+            if (ret != PLAYER_SUCCESS) {
+                return ret;
+            }
+        /*
+        } else if ((AVI_FILE == para->file_type)
+                && (VIDEO_DEC_FORMAT_MPEG4_3 != para->vstream_info.video_codec_type)
+                && (VFORMAT_H264 != para->vstream_info.video_format)
+                && (VFORMAT_VC1 != para->vstream_info.video_format)) {
+            ret = avi_write_header(para);
+            if (ret != PLAYER_SUCCESS) {
+                return ret;
+            }
+        */
+        } else if (CODEC_TAG_WMV3 == para->video_codec_tag) {
+            CLog::Log(LOGDEBUG, "CODEC_TAG_WMV3 == para->video_codec_tag");
+            ret = wmv3_write_header(para, pkt);
+            if (ret != PLAYER_SUCCESS) {
+                return ret;
+            }
+        } else if ((CODEC_TAG_WVC1 == para->video_codec_tag)
+                || (CODEC_TAG_VC_1 == para->video_codec_tag)
+                || (CODEC_TAG_WMVA == para->video_codec_tag)) {
+            CLog::Log(LOGDEBUG, "CODEC_TAG_WVC1 == para->video_codec_tag");
+            ret = wvc1_write_header(para, pkt);
+            if (ret != PLAYER_SUCCESS) {
+                return ret;
+            }
+        /*
+        } else if ((MKV_FILE == para->file_type) &&
+                  ((VFORMAT_MPEG4 == para->vstream_info.video_format)
+                || (VFORMAT_MPEG12 == para->vstream_info.video_format))) {
+            ret = mkv_write_header(para, pkt);
+            if (ret != PLAYER_SUCCESS) {
+                return ret;
+            }
+        */
+        }
+
+        if (pkt->hdr) {
+            if (pkt->hdr->data) {
+                free(pkt->hdr->data);
+                pkt->hdr->data = NULL;
+            }
+            free(pkt->hdr);
+            pkt->hdr = NULL;
+        }
+    } else if (para->stream_type == HISI_STREAM_PS) {
+	 CLog::Log(LOGDEBUG, "[pre_header_feeding] 5");
+        if (pkt->hdr == NULL) {
+            pkt->hdr = (hdr_buf_t*)malloc(sizeof(hdr_buf_t));
+            pkt->hdr->data = (char*)malloc(HDR_BUF_SIZE);
+            if (!pkt->hdr->data) {
+                CLog::Log(LOGDEBUG, "[pre_header_feeding] NOMEM!");
+                return PLAYER_NOMEM;
+            }
+        }
+        if (( AV_CODEC_ID_MPEG1VIDEO == para->video_codec_id)
+          || (AV_CODEC_ID_MPEG2VIDEO == para->video_codec_id)
+          || (AV_CODEC_ID_MPEG2VIDEO_XVMC == para->video_codec_id)) {
+            ret = mpeg_add_header(para, pkt);
+            if (ret != PLAYER_SUCCESS) {
+                return ret;
+            }
+        }
+        if (pkt->hdr) {
+            if (pkt->hdr->data) {
+                free(pkt->hdr->data);
+                pkt->hdr->data = NULL;
+            }
+            free(pkt->hdr);
+            pkt->hdr = NULL;
+        }
+    }
+
+	 CLog::Log(LOGDEBUG, "[pre_header_feeding] 6");
+    return PLAYER_SUCCESS;
+}
+
+static int h264_update_frame_header(hisi_packet_t *pkt)
+{
+    int nalsize, size = pkt->data_size;
+    unsigned char *data = pkt->data;
+    unsigned char *p = data;
+    if (p != NULL) {
+        if (check_size_in_buffer(p, size)) {
+            while ((p + 4) < (data + size)) {
+                nalsize = (*p << 24) | (*(p + 1) << 16) | (*(p + 2) << 8) | (*(p + 3));
+                *p = 0;
+                *(p + 1) = 0;
+                *(p + 2) = 0;
+                *(p + 3) = 1;
+                p += (nalsize + 4);
+            }
+            return PLAYER_SUCCESS;
+        } else if (check_size_in_buffer3(p, size)) {
+            while ((p + 3) < (data + size)) {
+                nalsize = (*p << 16) | (*(p + 1) << 8) | (*(p + 2));
+                *p = 0;
+                *(p + 1) = 0;
+                *(p + 2) = 1;
+                p += (nalsize + 3);
+            }
+            return PLAYER_SUCCESS;
+        } else if (check_size_in_buffer2(p, size)) {
+            unsigned char *new_data;
+            int new_len = 0;
+
+            new_data = (unsigned char *)malloc(size + 2 * 1024);
+            if (!new_data) {
+                return PLAYER_NOMEM;
+            }
+
+            while ((p + 2) < (data + size)) {
+                nalsize = (*p << 8) | (*(p + 1));
+                *(new_data + new_len) = 0;
+                *(new_data + new_len + 1) = 0;
+                *(new_data + new_len + 2) = 0;
+                *(new_data + new_len + 3) = 1;
+                memcpy(new_data + new_len + 4, p + 2, nalsize);
+                p += (nalsize + 2);
+                new_len += nalsize + 4;
+            }
+
+            free(pkt->buf);
+
+            pkt->buf = new_data;
+            pkt->buf_size = size + 2 * 1024;
+            pkt->data = pkt->buf;
+            pkt->data_size = new_len;
+        }
+	 else
+	 {
+        CLog::Log(LOGDEBUG, "[%s]invalid size!", __FUNCTION__);
+        return PLAYER_FAILED;
+	 }
+    } else {
+        CLog::Log(LOGDEBUG, "[%s]invalid pointer!", __FUNCTION__);
+        return PLAYER_FAILED;
+    }
+    return PLAYER_SUCCESS;
+}
+
+static int divx3_prefix(hisi_packet_t *pkt)
+{
+#define DIVX311_CHUNK_HEAD_SIZE 13
+    const unsigned char divx311_chunk_prefix[DIVX311_CHUNK_HEAD_SIZE] = {
+        0x00, 0x00, 0x00, 0x01, 0xb6, 'D', 'I', 'V', 'X', '3', '.', '1', '1'
+    };
+    if ((pkt->hdr != NULL) && (pkt->hdr->data != NULL)) {
+        free(pkt->hdr->data);
+        pkt->hdr->data = NULL;
+    }
+
+    if (pkt->hdr == NULL) {
+        pkt->hdr = (hdr_buf_t*)malloc(sizeof(hdr_buf_t));
+        if (!pkt->hdr) {
+            CLog::Log(LOGDEBUG, "[divx3_prefix] NOMEM!");
+            return PLAYER_FAILED;
+        }
+
+        pkt->hdr->data = NULL;
+        pkt->hdr->size = 0;
+    }
+
+    pkt->hdr->data = (char*)malloc(DIVX311_CHUNK_HEAD_SIZE + 4);
+    if (pkt->hdr->data == NULL) {
+        CLog::Log(LOGDEBUG, "[divx3_prefix] NOMEM!");
+        return PLAYER_FAILED;
+    }
+
+    memcpy(pkt->hdr->data, divx311_chunk_prefix, DIVX311_CHUNK_HEAD_SIZE);
+
+    pkt->hdr->data[DIVX311_CHUNK_HEAD_SIZE + 0] = (pkt->data_size >> 24) & 0xff;
+    pkt->hdr->data[DIVX311_CHUNK_HEAD_SIZE + 1] = (pkt->data_size >> 16) & 0xff;
+    pkt->hdr->data[DIVX311_CHUNK_HEAD_SIZE + 2] = (pkt->data_size >>  8) & 0xff;
+    pkt->hdr->data[DIVX311_CHUNK_HEAD_SIZE + 3] = pkt->data_size & 0xff;
+
+    pkt->hdr->size = DIVX311_CHUNK_HEAD_SIZE + 4;
+    pkt->newflag = 1;
+
+    return PLAYER_SUCCESS;
+}
+
+static int set_v_header_info(hisi_private_t *para)
+{
+  hisi_packet_t *pkt = &para->hisi_pkt;
+
+  if (pkt->newflag)
+  {
+    if (pkt->hdr)
+      pkt->hdr->size = 0;
+
+    if ((para->video_format == VFORMAT_H264) /*|| (hisi_private->video_format == VFORMAT_H264MVC)*/)
+    {
+      return h264_update_frame_header(pkt);
+    }
+    else if (para->video_format == VFORMAT_MPEG4)
+    {
+      if (para->video_codec_type == VIDEO_DEC_FORMAT_MPEG4_3)
+      {
+        return divx3_prefix(pkt);
+      }
+      else if (para->video_codec_type == VIDEO_DEC_FORMAT_H263)
+      {
+        return PLAYER_UNSUPPORT;
+        unsigned char *vld_buf;
+        int vld_len, vld_buf_size = para->video_width * para->video_height * 2;
+
+        if (!pkt->data_size) {
+            return PLAYER_SUCCESS;
+        }
+
+        if ((pkt->data[0] == 0) && (pkt->data[1] == 0) && (pkt->data[2] == 1) && (pkt->data[3] == 0xb6)) {
+            return PLAYER_SUCCESS;
+        }
+
+        vld_buf = (unsigned char*)malloc(vld_buf_size);
+        if (!vld_buf) {
+            return PLAYER_NOMEM;
+        }
+#if 0
+        if (para->flv_flag) {
+            vld_len = para->m_dll->h263vld(pkt->data, vld_buf, pkt->data_size, 1);
+        } else {
+            if (0 == para->h263_decodable) {
+                para->h263_decodable = para->m_dll->decodeble_h263(pkt->data);
+                if (0 == para->h263_decodable) {
+                    CLog::Log(LOGDEBUG, "[%s]h263 unsupport video and audio, exit", __FUNCTION__);
+                    return PLAYER_UNSUPPORT;
+                }
+            }
+            vld_len = para->m_dll->h263vld(pkt->data, vld_buf, pkt->data_size, 0);
+        }
+#endif
+        if (vld_len > 0) {
+            if (pkt->buf) {
+                free(pkt->buf);
+            }
+            pkt->buf = vld_buf;
+            pkt->buf_size = vld_buf_size;
+            pkt->data = pkt->buf;
+            pkt->data_size = vld_len;
+        } else {
+            free(vld_buf);
+            pkt->data_size = 0;
+        }
+      }
+    }
+    else if (para->video_format == VFORMAT_VC1) {
+        if (para->video_codec_type == VIDEO_DEC_FORMAT_WMV3) {
+            unsigned i, check_sum = 0, data_len = 0;
+
+            if ((pkt->hdr != NULL) && (pkt->hdr->data != NULL)) {
+                free(pkt->hdr->data);
+                pkt->hdr->data = NULL;
+            }
+
+            if (pkt->hdr == NULL) {
+                pkt->hdr = (hdr_buf_t*)malloc(sizeof(hdr_buf_t));
+                if (!pkt->hdr) {
+                    return PLAYER_FAILED;
+                }
+
+                pkt->hdr->data = NULL;
+                pkt->hdr->size = 0;
+            }
+
+            if (pkt->avpkt.flags) {
+                pkt->hdr->data = (char*)malloc(para->extrasize + 26 + 22);
+                if (pkt->hdr->data == NULL) {
+                    return PLAYER_FAILED;
+                }
+
+                pkt->hdr->data[0] = 0;
+                pkt->hdr->data[1] = 0;
+                pkt->hdr->data[2] = 1;
+                pkt->hdr->data[3] = 0x10;
+
+                data_len = para->extrasize + 4;
+                pkt->hdr->data[4] = 0;
+                pkt->hdr->data[5] = (data_len >> 16) & 0xff;
+                pkt->hdr->data[6] = 0x88;
+                pkt->hdr->data[7] = (data_len >> 8) & 0xff;
+                pkt->hdr->data[8] =  data_len & 0xff;
+                pkt->hdr->data[9] = 0x88;
+
+                pkt->hdr->data[10] = 0xff;
+                pkt->hdr->data[11] = 0xff;
+                pkt->hdr->data[12] = 0x88;
+                pkt->hdr->data[13] = 0xff;
+                pkt->hdr->data[14] = 0xff;
+                pkt->hdr->data[15] = 0x88;
+
+                for (i = 4 ; i < 16 ; i++) {
+                    check_sum += pkt->hdr->data[i];
+                }
+
+                pkt->hdr->data[16] = (check_sum >> 8) & 0xff;
+                pkt->hdr->data[17] =  check_sum & 0xff;
+                pkt->hdr->data[18] = 0x88;
+                pkt->hdr->data[19] = (check_sum >> 8) & 0xff;
+                pkt->hdr->data[20] =  check_sum & 0xff;
+                pkt->hdr->data[21] = 0x88;
+
+                pkt->hdr->data[22] = (para->video_width  >> 8) & 0xff;
+                pkt->hdr->data[23] =  para->video_width  & 0xff;
+                pkt->hdr->data[24] = (para->video_height >> 8) & 0xff;
+                pkt->hdr->data[25] =  para->video_height & 0xff;
+
+                memcpy(pkt->hdr->data + 26, para->extradata, para->extrasize);
+
+                check_sum = 0;
+                data_len = para->extrasize + 26;
+            }
+            else {
+                pkt->hdr->data = (char*)malloc(22);
+                if (pkt->hdr->data == NULL) {
+                    return PLAYER_FAILED;
+                }
+            }
+
+            pkt->hdr->data[data_len + 0]  = 0;
+            pkt->hdr->data[data_len + 1]  = 0;
+            pkt->hdr->data[data_len + 2]  = 1;
+            pkt->hdr->data[data_len + 3]  = 0xd;
+
+            pkt->hdr->data[data_len + 4]  = 0;
+            pkt->hdr->data[data_len + 5]  = (pkt->data_size >> 16) & 0xff;
+            pkt->hdr->data[data_len + 6]  = 0x88;
+            pkt->hdr->data[data_len + 7]  = (pkt->data_size >> 8) & 0xff;
+            pkt->hdr->data[data_len + 8]  =  pkt->data_size & 0xff;
+            pkt->hdr->data[data_len + 9]  = 0x88;
+
+            pkt->hdr->data[data_len + 10] = 0xff;
+            pkt->hdr->data[data_len + 11] = 0xff;
+            pkt->hdr->data[data_len + 12] = 0x88;
+            pkt->hdr->data[data_len + 13] = 0xff;
+            pkt->hdr->data[data_len + 14] = 0xff;
+            pkt->hdr->data[data_len + 15] = 0x88;
+
+            for (i = data_len + 4 ; i < data_len + 16 ; i++) {
+                check_sum += pkt->hdr->data[i];
+            }
+
+            pkt->hdr->data[data_len + 16] = (check_sum >> 8) & 0xff;
+            pkt->hdr->data[data_len + 17] =  check_sum & 0xff;
+            pkt->hdr->data[data_len + 18] = 0x88;
+            pkt->hdr->data[data_len + 19] = (check_sum >> 8) & 0xff;
+            pkt->hdr->data[data_len + 20] =  check_sum & 0xff;
+            pkt->hdr->data[data_len + 21] = 0x88;
+
+            pkt->hdr->size = data_len + 22;
+            pkt->newflag = 1;
+        }
+	 else if (para->video_codec_type == VIDEO_DEC_FORMAT_WVC1) {
+            if ((pkt->hdr != NULL) && (pkt->hdr->data != NULL)) {
+                free(pkt->hdr->data);
+                pkt->hdr->data = NULL;
+            }
+
+            if (pkt->hdr == NULL) {
+                pkt->hdr = (hdr_buf_t*)malloc(sizeof(hdr_buf_t));
+                if (!pkt->hdr) {
+                    CLog::Log(LOGDEBUG, "[wvc1_prefix] NOMEM!");
+                    return PLAYER_FAILED;
+                }
+
+                pkt->hdr->data = NULL;
+                pkt->hdr->size = 0;
+            }
+
+            pkt->hdr->data = (char*)malloc(4);
+            if (pkt->hdr->data == NULL) {
+                CLog::Log(LOGDEBUG, "[wvc1_prefix] NOMEM!");
+                return PLAYER_FAILED;
+            }
+
+            pkt->hdr->data[0] = 0;
+            pkt->hdr->data[1] = 0;
+            pkt->hdr->data[2] = 1;
+            pkt->hdr->data[3] = 0xd;
+            pkt->hdr->size = 4;
+            pkt->newflag = 1;
+        }
+    }
+  }
+  return PLAYER_SUCCESS;
+}
+
+
+
+CHisiVideoCodec::CHisiVideoCodec() : CThread("CHisiVideoCodec")
+{
+#if 0
+  m_bData_236 = 0;
+  m_bData_237 = 0;
+  m_Data_240 = 0;
+#endif
+
+  hisi_private = new hisi_private_t;
+  memset(hisi_private, 0, sizeof(hisi_private_t));
+
+  m_dll_sample/*176*/ = new DllLibHiSample;
+  m_dll_comm/*180*/ = new DllLibHiComm;
+  m_dll_mpi/*184*/ = new DllLibHiMpi;
+
+  m_dll_sample->Load();
+  m_dll_comm->Load();
+  m_dll_mpi->Load();
+  //6b2ee8
+  hisi_private->m_dll_sample = m_dll_sample;
+  hisi_private->m_dll_comm = m_dll_comm;
+  hisi_private->m_dll_mpi = m_dll_mpi;
+
+  hisi_private->m_hAvplay = m_hAvplay;
+  hisi_private->m_hWin = m_hWin;
+}
+
+
+CHisiVideoCodec::~CHisiVideoCodec()
+{
+  StopThread();
+
+  delete hisi_private;
+  hisi_private = NULL;
+
+  delete m_dll_sample, m_dll_sample = NULL;
+  delete m_dll_comm, m_dll_comm = NULL;
+  delete m_dll_mpi, m_dll_mpi = NULL;
+}
+
+static vformat_t codecid_to_vformat(enum AVCodecID id)
+{
+  vformat_t format;
+  switch (id)
+  {
+    case AV_CODEC_ID_MPEG1VIDEO: //1
+    case AV_CODEC_ID_MPEG2VIDEO: //2
+    case AV_CODEC_ID_MPEG2VIDEO_XVMC: //3
+      format = VFORMAT_MPEG12; //0
+      break;
+    case AV_CODEC_ID_H263: //5
+    case AV_CODEC_ID_MPEG4:
+    case AV_CODEC_ID_H263P:
+    case AV_CODEC_ID_H263I:
+    case AV_CODEC_ID_MSMPEG4V2:
+    case AV_CODEC_ID_MSMPEG4V3:
+    case AV_CODEC_ID_FLV1:
+      format = VFORMAT_MPEG4; //1
+      break;
+    case AV_CODEC_ID_RV10:
+    case AV_CODEC_ID_RV20:
+    case AV_CODEC_ID_RV30:
+    case AV_CODEC_ID_RV40:
+      format = VFORMAT_REAL; //4
+      break;
+    case AV_CODEC_ID_H264:
+      format = VFORMAT_H264;
+      break;
+    /*
+    case AV_CODEC_ID_H264MVC:
+      // H264 Multiview Video Coding (3d blurays)
+      format = VFORMAT_H264MVC;
+      break;
+    */
+    case AV_CODEC_ID_MJPEG:
+      format = VFORMAT_MJPEG;
+      break;
+    case AV_CODEC_ID_VC1:
+    case AV_CODEC_ID_WMV3:
+      format = VFORMAT_VC1;
+      break;
+    case AV_CODEC_ID_AVS:
+    case AV_CODEC_ID_CAVS:
+      format = VFORMAT_AVS;
+      break;
+#if 0
+    case AV_CODEC_ID_HEVC:
+      format = VFORMAT_HEVC;
+      break;
+#endif
+    default:
+      format = VFORMAT_UNSUPPORT;
+      break;
+  }
+
+  CLog::Log(LOGDEBUG, "codecid_to_vformat, id(%d) -> vformat(%d)", (int)id, format);
+  return format;
+}
+
+static HI_S32 HandleEvent(HI_HANDLE hAvplay, HI_UNF_AVPLAY_EVENT_E enEvent, HI_U32 u32Para)
+{
+  CLog::Log(LOGDEBUG, "CHisiVideoCodec::HandleEvent: enEvent=%d", enEvent);
+
+  if (enEvent == HI_UNF_AVPLAY_EVENT_NEW_VID_FRAME)
+  {
+    HI_UNF_VIDEO_FRAME_INFO_S* p = (HI_UNF_VIDEO_FRAME_INFO_S*) u32Para;
+
+    CLog::Log(LOGDEBUG, "CHisiVideoCodec::HandleEvent: u32FrameIndex=%d, u32SrcPts=%d, u32Pts=%d",
+			  p->u32FrameIndex, p->u32SrcPts, p->u32Pts);
+
+#if 0
+	    HI_U32                              u32FrameIndex;      /**<Frame index ID of a video sequence*/ /**<CNcomment: ÊÓÆµÐòÁÐÖÐµÄÖ¡Ë÷ÒýºÅ*/
+	    HI_UNF_VIDEO_FRAME_ADDR_S           stVideoFrameAddr[2];
+	    HI_U32                              u32Width;           /**<Width of the source picture*/ /**<CNcomment: Ô­Ê¼Í¼Ïñ¿í*/
+	    HI_U32                              u32Height;          /**<Height of the source picture*/ /**<CNcomment: Ô­Ê¼Í¼Ïñ¸ß*/
+	    HI_U32                              u32SrcPts;          /**<Original PTS of a video frame*/ /**<CNcomment: ÊÓÆµÖ¡µÄÔ­Ê¼Ê±¼ä´Á*/
+	    HI_U32                              u32Pts;             /**<PTS of a video frame*/ /**<CNcomment: ÊÓÆµÖ¡µÄÊ±¼ä´Á*/
+	    HI_U32                              u32AspectWidth;
+	    HI_U32                              u32AspectHeight;
+	    HI_UNF_VCODEC_FRMRATE_S             stFrameRate;
+
+	    HI_UNF_VIDEO_FORMAT_E               enVideoFormat;      /**<Video YUV format*/ /**<CNcomment: ÊÓÆµYUV¸ñÊ½*/
+	    HI_BOOL                             bProgressive;       /**<Sampling type (progressive or interlaced)*/ /**<CNcomment: ²ÉÑù·½Ê½(ÖðÐÐ/¸ôÐÐ) */
+	    HI_UNF_VIDEO_FIELD_MODE_E           enFieldMode;        /**<Frame or field encoding mode*/ /**<CNcomment: Ö¡»ò³¡±àÂëÄ£Ê½*/
+	    HI_BOOL                             bTopFieldFirst;     /**<Top field first flag*/ /**<CNcomment: ¶¥³¡ÓÅÏÈ±êÖ¾*/
+	    HI_UNF_VIDEO_FRAME_PACKING_TYPE_E   enFramePackingType; /**<3D frame packing type*/
+	    HI_U32                              u32Circumrotate;    /**<Need circumrotate, 1 need */
+	    HI_BOOL                             bVerticalMirror;
+	    HI_BOOL                             bHorizontalMirror;
+	    HI_U32                              u32DisplayWidth;    /**<Width of the displayed picture*/ /**<CNcomment: ÏÔÊ¾Í¼Ïñ¿í*/
+	    HI_U32                              u32DisplayHeight;   /**<Height of the displayed picture*/ /**<CNcomment: ÏÔÊ¾Í¼Ïñ¸ß*/
+	    HI_U32                              u32DisplayCenterX;  /**<Horizontal coordinate of the center of the displayed picture (the upper left point of the source picture serves as the coordinate origin)*/ /**<CNcomment: ÏÔÊ¾ÖÐÐÄx×ø±ê£¬Ô­Ê¼Í¼Ïñ×óÉÏ½ÇÎª×ø±êÔ­µã*/
+	    HI_U32                              u32DisplayCenterY;  /**<Vertical coordinate of the center of the displayed picture (the upper left point of the source picture serves as the coordinate origin)*/ /**<CNcomment: ÏÔÊ¾ÖÐÐÄy×ø±ê£¬Ô­Ê¼Í¼Ïñ×óÉÏ½ÇÎª×ø±êÔ­µã*/
+	    HI_U32                              u32ErrorLevel;      /**<Error percentage of a decoded picture, ranging from 0% to 100%*/ /**<CNcomment: Ò»·ù½âÂëÍ¼ÏñÖÐµÄ´íÎó±ÈÀý£¬È¡ÖµÎª0¡«100*/
+	    HI_U32                              u32Private[64];
+#endif
+  }
+  else if (enEvent == HI_UNF_AVPLAY_EVENT_SYNC_STAT_CHANGE)
+  {
+    HI_UNF_SYNC_STAT_PARAM_S* p = (HI_UNF_SYNC_STAT_PARAM_S*) u32Para;
+
+    CLog::Log(LOGDEBUG, "CHisiVideoCodec::HandleEvent: s32VidAudDiff=%d",
+			  p->s32VidAudDiff);
+
+#if 0
+    HI_S32          s32VidAudDiff;     /**<The diffrence between video and audio frames*//**<CNcomment: ÒôÊÓÆµ²îÖµ */
+    HI_S32          s32VidPcrDiff;     /**<The diffrence between video frame and pcr*//**<CNcomment: ÊÓÆµPCR²îÖµ */
+    HI_S32          s32AudPcrDiff;     /**<The diffrence between audio frame and pcr*//**<CNcomment: ÒôÆµPCR²îÖµ */
+    HI_U32          u32VidLocalTime;   /**<Local video synchronization reference time*//**<CNcomment: ÊÓÆµ±¾µØÊ±¼ä */
+    HI_U32          u32AudLocalTime;   /**<Local audio synchronization reference time*//**<CNcomment: ÒôÆµ±¾µØÊ±¼ä */
+    HI_U32          u32PcrLocalTime;   /**<Local pcr synchronization reference time*//**<CNcomment: PCR±¾µØÊ±¼ä */
+#endif
+  }
+
+  return HI_SUCCESS;
+}
+
+bool CHisiVideoCodec::OpenDecoder(CDVDStreamInfo &hints)
+{
+  HI_S32 s32Res;
+  HI_UNF_AVPLAY_ATTR_S AvplayAttr; //sp684;
+  HI_UNF_SYNC_ATTR_S AvSyncAttr; //sp784;
+  HI_UNF_ENC_FMT_E g_enDefaultFmt = HI_UNF_ENC_FMT_1080P_60; //TODO: spitzbube
+  HI_UNF_WINDOW_ATTR_S WinAttr; //sp548
+  HI_BOOL bAdvancedProfil = HI_TRUE; //v32
+  HI_U32  u32CodecVersion = 8; //v31
+
+  //RESOLUTION res = g_graphicsContext.GetVideoResolution();
+  RESOLUTION_INFO res_info = CDisplaySettings::Get().GetCurrentResolutionInfo();
+
+  WinAttr.enDisp   = HI_UNF_DISPLAY1; //s_stParam.u32Display;
+  WinAttr.bVirtual = HI_FALSE;
+  WinAttr.stWinAspectAttr.enAspectCvrs        = HI_UNF_VO_ASPECT_CVRS_IGNORE;//HI_UNF_VO_ASPECT_CVRS_LETTERBOX
+  WinAttr.stWinAspectAttr.bUserDefAspectRatio = HI_FALSE;
+  WinAttr.bUseCropRect      = HI_FALSE;
+  WinAttr.stInputRect.s32X  = 0;
+  WinAttr.stInputRect.s32Y  = 0;
+  WinAttr.stInputRect.s32Width  = hints.width;
+  WinAttr.stInputRect.s32Height = hints.height;
+
+#if 0 //Spitzbube: TODO
+  g_enDefaultFmt = (HI_UNF_ENC_FMT_E)hi_get_disp1_res();
+//  CLog::Log(LOGDEBUG, "hi_get_disp1_res-(%s)", v166);
+//  CLog::Log(LOGDEBUG, "hi_get_disp1_res-(%d)", v21);
+#endif
+
+  switch(g_enDefaultFmt)
+  {
+    case HI_UNF_ENC_FMT_1080i_60:
+    case HI_UNF_ENC_FMT_1080P_60:
+    case HI_UNF_ENC_FMT_1080i_50:
+    case HI_UNF_ENC_FMT_1080P_50:
+       WinAttr.stOutputRect.s32Width = 1920;
+       WinAttr.stOutputRect.s32Height = 1080;
+       break;
+    case HI_UNF_ENC_FMT_720P_60:
+    case HI_UNF_ENC_FMT_720P_50:
+       WinAttr.stOutputRect.s32Width = 1280;
+       WinAttr.stOutputRect.s32Height = 720;
+       break;
+    case HI_UNF_ENC_FMT_576P_50:
+       WinAttr.stOutputRect.s32Width = 720;
+       WinAttr.stOutputRect.s32Height = 576;
+       break;
+    case HI_UNF_ENC_FMT_480P_60:
+       WinAttr.stOutputRect.s32Width = 720;
+       WinAttr.stOutputRect.s32Height = 480;
+       break;
+    default:
+       WinAttr.stOutputRect.s32Width = 1920;
+       WinAttr.stOutputRect.s32Height = 1080;
+       break;
+  }
+
+  WinAttr.stOutputRect.s32X = 100;
+  WinAttr.stOutputRect.s32Y = 60;
+  WinAttr.stOutputRect.s32Width = (WinAttr.stOutputRect.s32Width - WinAttr.stOutputRect.s32X);
+  WinAttr.stOutputRect.s32Height = (WinAttr.stOutputRect.s32Height - WinAttr.stOutputRect.s32Y);
+  WinAttr.stOutputRect.s32X /= 2;
+  WinAttr.stOutputRect.s32Y /= 2;
+
+  CLog::Log(LOGDEBUG, "CHisiVideoCodec::OpenDecoder(format:%d, w:%d, h:%d, fr:%d)",
+  	g_enDefaultFmt, res_info.iScreenWidth, res_info.iScreenHeight, (int)res_info.fRefreshRate);
+
+  g_m_hvsync = 0;
+
+  m_1st_pts = 0;
+  m_cur_pts = 0;
+  m_cur_pictcnt = 0;
+  m_old_pictcnt = 0;
+  m_dst_rect.SetRect(0, 0, 0, 0);
+  m_dst_rect_prev.SetRect(0, 0, 0, 0);
+  m_zoom           = -1;
+  m_contrast       = -1;
+  m_brightness     = -1;
+  m_vbufsize = 500000 * 2;
+  m_VdecType = HI_UNF_VCODEC_TYPE_BUTT;
+  m_speed = DVD_PLAYSPEED_NORMAL;
+  m_opened = false;
+
+  switch (hints.codec)
+  {
+  case AV_CODEC_ID_MPEG1VIDEO: //1
+  case AV_CODEC_ID_MPEG2VIDEO: //2
+  case AV_CODEC_ID_MPEG2VIDEO_XVMC: //3
+	m_VdecType = HI_UNF_VCODEC_TYPE_MPEG2/*0*/;
+    break;
+  case AV_CODEC_ID_H263: //5
+  case AV_CODEC_ID_H263P: //20
+  case AV_CODEC_ID_H263I: //21
+	m_VdecType = HI_UNF_VCODEC_TYPE_H263/*3*/;
+	break;
+  case AV_CODEC_ID_RV10: //6
+  case AV_CODEC_ID_RV20: //7
+  case AV_CODEC_ID_RV30: //70 = 0x46u?
+  case AV_CODEC_ID_RV40: //71 = 0x47u?
+	m_VdecType = HI_UNF_VCODEC_TYPE_REAL9/*6*/;
+    break;
+  case AV_CODEC_ID_MPEG4: //13
+  case AV_CODEC_ID_MSMPEG4V2: //16
+  case AV_CODEC_ID_MSMPEG4V3: //17
+	m_VdecType = HI_UNF_VCODEC_TYPE_MPEG4/*1*/;
+    break;
+  case AV_CODEC_ID_FLV1: //22 = 0x16u
+  case AV_CODEC_ID_WMV3: //0x49u
+	m_VdecType = HI_UNF_VCODEC_TYPE_VC1/*7*/;
+	bAdvancedProfil = HI_FALSE/*0*/;
+	u32CodecVersion = 5;
+    break;
+  case AV_CODEC_ID_H264: //28 = 0x1Cu
+	m_VdecType = HI_UNF_VCODEC_TYPE_H264/*4*/;
+    break;
+  case AV_CODEC_ID_VC1: //0x48u
+	m_VdecType = HI_UNF_VCODEC_TYPE_VC1/*7*/;
+    break;
+  case AV_CODEC_ID_VP6: //0x5Du:
+	m_VdecType = HI_UNF_VCODEC_TYPE_VP6/*8*/;
+    break;
+  case AV_CODEC_ID_VP6F: //0x5Eu:
+	m_VdecType = HI_UNF_VCODEC_TYPE_VP6F/*9*/;
+    break;
+  case AV_CODEC_ID_VP8: //0x91u:
+	m_VdecType = HI_UNF_VCODEC_TYPE_VP8/*16*/;
+    break;
+
+  default:
+    CLog::Log(LOGERROR, "Codec not supported codec = 0x%x", hints.codec);
+    return false;
+  }
+
+  CLog::Log(LOGDEBUG, "CHisiVideoCodec::OpenDecoder : m_VdecType(%d)", m_VdecType/*v33*/);
+
+  m_dll_comm->HI_SYS_Init();
+  m_dll_comm->HI_SYS_PreAV(NULL);
+
+  s32Res = m_dll_mpi->HI_UNF_AVPLAY_Init();
+  if (s32Res != HI_SUCCESS)
+  {
+    //6b6074
+    CLog::Log(LOGERROR, "call HI_UNF_AVPLAY_Init failed. ret=0x%x", s32Res);
+    //6b6084
+    goto SND_DEINIT;
+  }
+  //6b61ec
+  s32Res = m_dll_mpi->HI_UNF_AVPLAY_GetDefaultConfig(&AvplayAttr, HI_UNF_AVPLAY_STREAM_TYPE_ES);
+  s32Res |= m_dll_mpi->HI_UNF_AVPLAY_Create(&AvplayAttr, &m_hAvplay);
+  if (s32Res != HI_SUCCESS)
+  {
+    //6b6228
+    CLog::Log(LOGERROR, "call HI_UNF_AVPLAY_Create failed. ret=0x%x", s32Res);
+    //6b6238
+    goto AVPLAY_DEINIT;
+  }
+  //6b624c
+  g_m_hAvplay = m_hAvplay;
+
+  s32Res = m_dll_mpi->HI_UNF_AVPLAY_GetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_SYNC, &AvSyncAttr);
+#if 0
+  AvSyncAttr.enSyncRef = HI_UNF_SYNC_REF_NONE; //0
+#else
+  AvSyncAttr.enSyncRef = HI_UNF_SYNC_REF_AUDIO;
+  AvSyncAttr.stSyncStartRegion.s32VidPlusTime = 60;
+  AvSyncAttr.stSyncStartRegion.s32VidNegativeTime = -20;
+  AvSyncAttr.bQuickOutput = HI_FALSE;
+#endif
+  s32Res |= m_dll_mpi->HI_UNF_AVPLAY_SetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_SYNC, &AvSyncAttr);
+  if (s32Res != HI_SUCCESS)
+  {
+    //6b62a8
+	CLog::Log(LOGERROR, "call HI_UNF_AVPLAY_SetAttr failed. ret=0x%x", s32Res);
+	//->6b6238
+    goto AVPLAY_DEINIT;
+  }
+  //6b62c8
+  s32Res = m_dll_sample->HIADP_Disp_Init(g_enDefaultFmt);
+  if (s32Res != HI_SUCCESS)
+  {
+    //6b62e4
+    CLog::Log(LOGERROR, "call DispInit failed. ret=0x%x", s32Res);
+    //->6b60b8
+    goto SYS_DEINIT;
+  }
+  //6b6304
+  m_dll_mpi->HI_UNF_DISP_SetLayerZorder(HI_UNF_DISPLAY1, HI_UNF_DISP_LAYER_VIDEO, HI_LAYER_ZORDER_MOVEBOTTOM);
+  m_dll_mpi->HI_UNF_DISP_SetLayerZorder(HI_UNF_DISPLAY1, HI_UNF_DISP_LAYER_GFX, HI_LAYER_ZORDER_MOVETOP);
+
+  s32Res = m_dll_mpi->HI_UNF_VO_Init(HI_UNF_VO_DEV_MODE_MOSAIC);
+  if (s32Res != HI_SUCCESS)
+  {
+    //->6b6384
+    CLog::Log(LOGERROR, "call VO_Init failed. ret=0x%x", s32Res);
+    //->6b60a8
+    goto DISP_DEINIT;
+  }
+  //6b6354
+  s32Res = m_dll_mpi->HI_UNF_VO_Open(1);
+  if (s32Res != HI_SUCCESS)
+  {
+    //6b6370
+    CLog::Log(LOGERROR, "call VO_Open failed. ret=0x%x", s32Res);
+    //->6b60a8
+    goto DISP_DEINIT;
+  }
+  //6b6398
+#if 0 //Spitzbube: TODO
+  memset(&WinAttr, 0, sizeof(WinAttr));
+  WinAttr.enDisp   = HI_UNF_DISPLAY1; //s_stParam.u32Display;
+  WinAttr.bVirtual = HI_FALSE;
+  WinAttr.stWinAspectAttr.enAspectCvrs        = HI_UNF_VO_ASPECT_CVRS_LETTERBOX;//HI_UNF_VO_ASPECT_CVRS_IGNORE;//HI_UNF_VO_ASPECT_CVRS_LETTERBOX
+  WinAttr.stWinAspectAttr.bUserDefAspectRatio = HI_FALSE;
+  WinAttr.bUseCropRect      = HI_FALSE;
+  WinAttr.stInputRect.s32X  = 0;
+  WinAttr.stInputRect.s32Y  = 0;
+  WinAttr.stInputRect.s32Width  = 0;
+  WinAttr.stInputRect.s32Height = 0;
+  WinAttr.stOutputRect.s32X = 0; //s_stParam.x;
+  WinAttr.stOutputRect.s32Y = 0; //s_stParam.y;
+  WinAttr.stOutputRect.s32Width  = 0; //s_stParam.w;
+  WinAttr.stOutputRect.s32Height = 0; //s_stParam.h;
+#endif
+
+  s32Res = m_dll_mpi->HI_UNF_VO_CreateWindow(&WinAttr, &m_hWin);
+  if (s32Res != HI_SUCCESS)
+  {
+    //6b63cc
+    CLog::Log(LOGERROR, "call VO_CreatWin failed. ret=0x%x", s32Res);
+    //->6b6098
+    m_dll_sample->HIADP_VO_DeInit();
+    goto DISP_DEINIT;
+  }
+  //6b641c
+  s32Res = m_dll_mpi->HI_UNF_AVPLAY_ChnOpen(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_VID, NULL);
+  if (s32Res != HI_SUCCESS)
+  {
+    //6b643c
+    CLog::Log(LOGERROR, "call HI_UNF_AVPLAY_ChnOpen failed. ret=0x%x", s32Res);
+    //6b644c
+    goto AVPLAY_DESTROY;
+  }
+  //6b6464
+  HI_UNF_VCODEC_ATTR_S VcodecAttr; //sp736;
+
+  s32Res = m_dll_mpi->HI_UNF_AVPLAY_GetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_VDEC, &VcodecAttr);
+  //6b6480
+#if 0 //Spitzbube: TODO
+  VcodecAttr.stCompressAttr.s32WatermarkFlag = 0;
+  VcodecAttr.stCompressAttr.s32WMStartLine = 0;
+  VcodecAttr.stCompressAttr.s32WMEndLine = 100;
+#endif
+  if (HI_UNF_VCODEC_TYPE_VC1 == m_VdecType)
+  {
+      VcodecAttr.unExtAttr.stVC1Attr.bAdvancedProfile = bAdvancedProfil; //740 = 4
+      VcodecAttr.unExtAttr.stVC1Attr.u32CodecVersion = u32CodecVersion; //744 = 8
+  }
+
+  if (HI_UNF_VCODEC_TYPE_VP6 == m_VdecType)
+  {
+      VcodecAttr.unExtAttr.stVP6Attr.bReversed = HI_FALSE/*0*/; //740 = 4
+  }
+//  VcodecAttr.enType = VdecType;
+
+  s32Res |= m_dll_mpi->HI_UNF_AVPLAY_SetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_VDEC, &VcodecAttr);
+  if (s32Res != HI_SUCCESS)
+  {
+	//6b64d8
+    CLog::Log(LOGERROR, "call HI_UNF_AVPLAY_SetAttr failed. ret=0x%x", s32Res);
+    //->6b6238
+    goto AVPLAY_DEINIT;
+  }
+  //6b64ec
+  s32Res = m_dll_mpi->HI_UNF_VO_AttachWindow(m_hWin, m_hAvplay);
+  if (s32Res != HI_SUCCESS)
+  {
+    //6b650c
+    CLog::Log(LOGERROR, "call HI_UNF_VO_AttachWindow failed. ret=0x%x", s32Res);
+    //6b651c
+    goto VCHN_CLOSE;
+  }
+  //6b6538
+  s32Res = m_dll_mpi->HI_UNF_VO_SetWindowEnable(m_hWin, HI_TRUE);
+  if (s32Res != HI_SUCCESS)
+  {
+	//6b6558
+	CLog::Log(LOGERROR, "call HI_UNF_VO_SetWindowEnable failed. ret=0x%x", s32Res);
+	//6b656c
+	goto WIN_DETATCH;
+  }
+  //6b66d4
+  s32Res = m_dll_sample->HIADP_AVPlay_SetVdecAttr(m_hAvplay, m_VdecType, HI_UNF_VCODEC_MODE_NORMAL);
+  if (s32Res != HI_SUCCESS)
+  {
+    //6b66f4
+	CLog::Log(LOGERROR, "call HIADP_AVPlay_SetVdecAttr failed. ret=0x%x", s32Res);
+    //->6b656c
+	goto WIN_DETATCH;
+  }
+  //6b670c
+  s32Res = m_dll_mpi->HI_UNF_AVPLAY_Start(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_VID, NULL);
+  if (s32Res != HI_SUCCESS)
+  {
+	//6b672c
+	CLog::Log(LOGERROR, "call HI_UNF_AVPLAY_Start failed. ret=0x%x", s32Res);
+	//->6b656c
+	goto WIN_DETATCH;
+  }
+  //6b6808
+  m_opened = true;
+
+  m_dll_mpi->HI_UNF_VO_SetWindowEnable(m_hWin, HI_FALSE);
+
+  hisi_packet_init(&hisi_private->hisi_pkt);
+
+  hisi_private->stream_type/*4376*/ = HISI_STREAM_ES/*3*/;
+
+  hisi_private->video_width = hints.width/*24*/;
+  hisi_private->video_height = hints.height/*20*/;
+  hisi_private->video_codec_id = hints.codec/*0*/;
+  hisi_private->video_codec_tag = hints.codec_tag/*88*/;
+
+  // handle video rate
+  if ((hints.fpsrate/*16*/ > 0) && (hints.fpsscale/*12*/ != 0))
+  {
+    //6b68d0
+    // then ffmpeg avg_frame_rate next
+    hisi_private->video_rate = 0.5 + (float)UNIT_FREQ * hints.fpsscale / hints.fpsrate;
+  }
+  else
+  {
+    //6b6c90
+	// stupid PVR hacks because it does not fill in all of hints.
+	if (hints.codec == AV_CODEC_ID_MPEG2VIDEO)
+	{
+	  hisi_private->video_rate = 0.5 + (float)UNIT_FREQ * 1001 / 30000;
+	  if (hints.width == 1280)
+		hisi_private->video_rate = 0.5 + (float)UNIT_FREQ * 1001 / 60000;
+	}
+  }
+
+  // check for 1920x1080, interlaced, 25 fps
+  // incorrectly reported as 50 fps (yes, video_rate == 1920)
+  if (hints.width == 1920 && hisi_private->video_rate == 1920)
+  {
+    CLog::Log(LOGDEBUG, "CHisiVideoCodec::OpenDecoder video_rate exception");
+    hisi_private->video_rate = 0.5 + (float)UNIT_FREQ * 1001 / 25000;
+  }
+
+  // check for SD h264 content incorrectly reported as 60 fsp
+  // mp4/avi containers :(
+  if (hints.codec == AV_CODEC_ID_H264 && hints.width <= 720 && hisi_private->video_rate == 1602)
+  {
+    CLog::Log(LOGDEBUG, "CHisiVideoCodec::OpenDecoder video_rate exception");
+    hisi_private->video_rate = 0.5 + (float)UNIT_FREQ * 1001 / 24000;
+  }
+
+  // check for SD h264 content incorrectly reported as 30 fsp
+  // mp4/avi containers :(
+  if (hints.codec == AV_CODEC_ID_H264 && hints.width <= 720 && hisi_private->video_rate == 3203)
+  {
+    CLog::Log(LOGDEBUG, "CHisiVideoCodec::OpenDecoder video_rate exception");
+    hisi_private->video_rate = 0.5 + (float)UNIT_FREQ * 1001 / 24000;
+  }
+
+  // handle orientation
+  hisi_private->video_rotation_degree = 0;
+  if (hints.orientation == 90)
+    hisi_private->video_rotation_degree = 1;
+  else if (hints.orientation == 180)
+    hisi_private->video_rotation_degree = 2;
+  else if (hints.orientation == 270)
+    hisi_private->video_rotation_degree = 3;
+
+  //6b698c
+  hisi_private->video_format = codecid_to_vformat(hints.codec);
+
+  // handle extradata
+  switch (hisi_private->video_format)
+  {
+    default:
+      //6b69ac
+      hisi_private->extrasize = hints.extrasize/*84*/;
+      hisi_private->extradata = (uint8_t*)malloc(hints.extrasize);
+      memcpy(hisi_private->extradata, hints.extradata/*80*/, hints.extrasize);
+#if 1 //extradata debug
+      //6b69dc
+      {
+    	for (int i = 0; i < hisi_private->extrasize; i += 8)
+    	{
+          uint8_t* p = &hisi_private->extradata[i];
+    	  CLog::Log(LOGDEBUG, "extradata %02x %02x %02x %02x %02x %02x %02x %02x",
+    			  p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);
+    	}
+      }
+#endif
+      break;
+    case VFORMAT_REAL: //0
+    case VFORMAT_MPEG12: //4
+      break;
+  }
+  //6b6a58
+  if (hisi_private->stream_type == HISI_STREAM_ES && hisi_private->video_codec_tag != 0)
+    hisi_private->video_codec_type = codec_tag_to_vdec_type(hisi_private->video_codec_tag);
+  else
+    hisi_private->video_codec_type = codec_tag_to_vdec_type(hisi_private->video_codec_id);
+
+  hisi_private->flv_flag = 0;
+  if (hisi_private->video_codec_id == AV_CODEC_ID_FLV1)
+  {
+    hisi_private->video_codec_tag = CODEC_TAG_F263;
+    hisi_private->flv_flag = 1;
+  }
+
+  CLog::Log(LOGDEBUG, "CHisiVideoCodec::OpenDecoder : video_format(%d)",
+		  hisi_private->video_format);
+  //6b6adc
+  CLog::Log(LOGDEBUG, "CHisiVideoCodec::OpenDecoder hints.fpsrate(%d), hints.fpsscale(%d), video_rate(%d)",
+    hints.fpsrate, hints.fpsscale, hisi_private->video_rate);
+  //6b6b08
+  CLog::Log(LOGDEBUG, "CHisiVideoCodec::OpenDecoder hints.orientation(%d), hints.forced_aspect(%d)",
+    hints.orientation, hints.forced_aspect);
+
+  // default video codec params
+  hisi_private->vcodec.has_video   = 1;
+  hisi_private->vcodec.noblock     = 0;
+  hisi_private->vcodec.video_pid   = hisi_private->video_pid;
+  hisi_private->vcodec.video_type  = hisi_private->video_format;
+  hisi_private->vcodec.stream_type = STREAM_TYPE_ES_VIDEO;
+  hisi_private->vcodec.hisi_sysinfo.format  = hisi_private->video_codec_type;
+  hisi_private->vcodec.hisi_sysinfo.width   = hisi_private->video_width;
+  hisi_private->vcodec.hisi_sysinfo.height  = hisi_private->video_height;
+  hisi_private->vcodec.hisi_sysinfo.rate    = hisi_private->video_rate;
+  //hisi_private->vcodec.hisi_sysinfo.ratio   = hisi_private->video_ratio;
+  //hisi_private->vcodec.hisi_sysinfo.ratio64 = hisi_private->video_ratio64;
+  hisi_private->vcodec.hisi_sysinfo.param   = NULL;
+
+  switch(hisi_private->video_format)
+  {
+    default:
+      break;
+    case VFORMAT_MPEG4:
+      hisi_private->vcodec.hisi_sysinfo.param = (void*)EXTERNAL_PTS;
+      break;
+    case VFORMAT_H264:
+    case VFORMAT_H264MVC:
+      hisi_private->vcodec.hisi_sysinfo.format  = VIDEO_DEC_FORMAT_H264;
+      hisi_private->vcodec.hisi_sysinfo.param = (void*)(EXTERNAL_PTS | SYNC_OUTSIDE);
+      break;
+    case VFORMAT_REAL:
+      hisi_private->stream_type = HISI_STREAM_RM;
+      hisi_private->vcodec.stream_type = STREAM_TYPE_ES_VIDEO;
+      hisi_private->vcodec.hisi_sysinfo.ratio = 0x100;
+      hisi_private->vcodec.hisi_sysinfo.ratio64 = 0;
+      {
+        static unsigned short tbl[9] = {0};
+        if (VIDEO_DEC_FORMAT_REAL_8 == hisi_private->video_codec_type)
+        {
+          hisi_private->vcodec.hisi_sysinfo.extra = hisi_private->extradata[1] & 7;
+          tbl[0] = (((hisi_private->vcodec.hisi_sysinfo.width  >> 2) - 1) << 8)
+                 | (((hisi_private->vcodec.hisi_sysinfo.height >> 2) - 1) & 0xff);
+          unsigned int j;
+          for (unsigned int i = 1; i <= hisi_private->vcodec.hisi_sysinfo.extra; i++)
+          {
+            j = 2 * (i - 1);
+            tbl[i] = ((hisi_private->extradata[8 + j] - 1) << 8) | ((hisi_private->extradata[8 + j + 1] - 1) & 0xff);
+          }
+        }
+        hisi_private->vcodec.hisi_sysinfo.param = &tbl;
+      }
+      break;
+    case VFORMAT_VC1:
+      // vc1 is extension id, from 0xfd55 to 0xfd5f according to ffmpeg
+      hisi_private->vcodec.video_pid = hisi_private->vcodec.video_pid >> 8;
+      break;
+  }
+
+  hisi_private->vcodec.hisi_sysinfo.param = (void *)((unsigned int)hisi_private->vcodec.hisi_sysinfo.param | (hisi_private->video_rotation_degree << 16));
+
+  hisi_private->hisi_pkt.codec/*132*/ = &hisi_private->vcodec;
+
+  hisi_private->m_hAvplay = m_hAvplay;
+  hisi_private->m_preloading_done = 0;
+
+  m_dll_mpi->HI_UNF_AVPLAY_RegisterEvent(m_hAvplay, HI_UNF_AVPLAY_EVENT_NEW_VID_FRAME, HandleEvent);
+  m_dll_mpi->HI_UNF_AVPLAY_RegisterEvent(m_hAvplay, HI_UNF_AVPLAY_EVENT_SYNC_PTS_JUMP, HandleEvent);
+  m_dll_mpi->HI_UNF_AVPLAY_RegisterEvent(m_hAvplay, HI_UNF_AVPLAY_EVENT_SYNC_STAT_CHANGE, HandleEvent);
+  m_dll_mpi->HI_UNF_AVPLAY_RegisterEvent(m_hAvplay, HI_UNF_AVPLAY_EVENT_VID_BUF_STATE, HandleEvent);
+
+  u32VidFrameCount = 0;
+  //6b6cfc
+  Create();
+
+  g_renderManager.RegisterRenderUpdateCallBack((const void*)this, RenderUpdateCallBack);
+  //->6b60dc
+  return true;
+
+WIN_DETATCH:
+  m_dll_mpi->HI_UNF_VO_SetWindowEnable(m_hWin, HI_FALSE);
+  m_dll_mpi->HI_UNF_VO_DetachWindow(m_hWin, m_hAvplay);
+  //->6b651c
+VCHN_CLOSE:
+  m_dll_mpi->HI_UNF_AVPLAY_ChnClose(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_VID);
+  //->6b644c
+AVPLAY_DESTROY:
+  m_dll_mpi->HI_UNF_AVPLAY_Destroy(m_hAvplay);
+  //->6b6238
+AVPLAY_DEINIT:
+  m_dll_mpi->HI_UNF_AVPLAY_DeInit();
+  //->6b6084
+SND_DEINIT:
+  m_dll_mpi->HI_UNF_VO_DestroyWindow(m_hWin);
+  //6b6098
+  m_dll_sample->HIADP_VO_DeInit();
+
+DISP_DEINIT:
+  m_dll_sample->HIADP_Disp_DeInit();
+
+SYS_DEINIT:
+  m_dll_comm->HI_SYS_DeInit();
+
+  g_m_hAvplay = 0;
+
+  return false;
+}
+
+
+void CHisiVideoCodec::CloseDecoder()
+{
+  HI_UNF_AVPLAY_STOP_OPT_S sp;
+
+  CLog::Log(LOGDEBUG, "CHisiVideoCodec::CloseDecoder");
+
+  StopThread();
+
+  m_dll_mpi->HI_UNF_AVPLAY_UnRegisterEvent(m_hAvplay, HI_UNF_AVPLAY_EVENT_NEW_VID_FRAME);
+  m_dll_mpi->HI_UNF_AVPLAY_UnRegisterEvent(m_hAvplay, HI_UNF_AVPLAY_EVENT_SYNC_PTS_JUMP);
+  m_dll_mpi->HI_UNF_AVPLAY_UnRegisterEvent(m_hAvplay, HI_UNF_AVPLAY_EVENT_SYNC_STAT_CHANGE);
+  m_dll_mpi->HI_UNF_AVPLAY_UnRegisterEvent(m_hAvplay, HI_UNF_AVPLAY_EVENT_VID_BUF_STATE);
+
+  g_renderManager.RegisterRenderUpdateCallBack((const void*)NULL, NULL);
+
+  hisi_packet_release(&hisi_private->hisi_pkt);
+
+  free(hisi_private->extradata);
+  hisi_private->extradata = NULL;
+
+  m_opened = false;
+
+  m_dll_mpi->HI_UNF_VO_SetWindowEnable(m_hWin, HI_FALSE);
+
+  sp.enMode = HI_UNF_AVPLAY_STOP_MODE_BLACK;
+  sp.u32TimeoutMs = 0;
+  m_dll_mpi->HI_UNF_AVPLAY_Stop(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_VID, &sp);
+
+  m_dll_mpi->HI_UNF_VO_SetWindowEnable(m_hWin, HI_FALSE);
+  m_dll_mpi->HI_UNF_VO_DetachWindow(m_hWin, m_hAvplay);
+  m_dll_mpi->HI_UNF_AVPLAY_ChnClose(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_VID);
+  m_dll_mpi->HI_UNF_AVPLAY_Destroy(m_hAvplay);
+  m_dll_mpi->HI_UNF_AVPLAY_DeInit();
+  m_dll_mpi->HI_UNF_VO_DestroyWindow(m_hWin);
+  m_dll_sample->HIADP_VO_DeInit();
+  m_dll_sample->HIADP_Disp_DeInit();
+  m_dll_comm->HI_SYS_DeInit();
+
+  m_dll_sample->Unload();
+  m_dll_comm->Unload();
+  m_dll_mpi->Unload();
+
+  hisi_private->m_dll_sample = m_dll_sample = NULL;
+  hisi_private->m_dll_comm = m_dll_comm = NULL;
+  hisi_private->m_dll_mpi = m_dll_mpi = NULL;
+
+  hisi_private->m_hAvplay = m_hAvplay = 0;
+  hisi_private->m_hWin = m_hWin = 0;
+
+  g_m_hAvplay = 0;
+}
+
+
+int CHisiVideoCodec::Decode(uint8_t* pData, int size, double dts, double pts)
+{
+  CLog::Log(LOGDEBUG, "CHisiVideoCodec::Decode >> size=%d, dts=%f, pts=%f", size, dts, pts);
+
+  if (!m_opened)
+	return VC_BUFFER;
+  int rtn = 0;
+
+  // grr, m_RenderUpdateCallBackFn in g_renderManager is NULL'ed during
+  // g_renderManager.Configure call by player, which happens after the codec
+  // OpenDecoder call. So we need to restore it but it does not seem to stick :)
+  g_renderManager.RegisterRenderUpdateCallBack((const void*)this, RenderUpdateCallBack);
+
+#if 1
+  HI_S32 s32Res;
+
+  if (pData)
+  {
+    HI_UNF_STREAM_BUF_S StreamBuf;
+    HI_U32 u32TimeOutMs = 0;
+    HI_U32 u32PtsMs = 0xFFFFFFFF;
+#if 0
+    if (/*(double)AV_NOPTS_VALUE*/DVD_NOPTS_VALUE != pts)
+      u32PtsMs = (HI_U32)(pts/PTS_FREQ_MS);
+    else
+      u32PtsMs = (HI_U32)(dts/PTS_FREQ_MS);
+#endif
+
+    int Retry;
+    for (Retry = 0; Retry < 10; Retry++)
+    {
+      s32Res = m_dll_mpi->HI_UNF_AVPLAY_GetBuf(m_hAvplay, HI_UNF_AVPLAY_BUF_ID_ES_VID,
+    		  size, &StreamBuf, u32TimeOutMs);
+      if (HI_SUCCESS == s32Res)
+      {
+        memcpy(StreamBuf.pu8Data, pData, size);
+
+        s32Res = m_dll_mpi->HI_UNF_AVPLAY_PutBuf(m_hAvplay, HI_UNF_AVPLAY_BUF_ID_ES_VID,
+        		size, u32PtsMs);
+        if (HI_SUCCESS == s32Res)
+        {
+          rtn &= ~VC_ERROR;
+          rtn |= VC_BUFFER;
+        }
+        else
+        {
+          CLog::Log(LOGERROR, "CHisiVideoCodec::Decode, HI_UNF_AVPLAY_PutBuf failed(0x%x)", s32Res);
+          rtn |= VC_ERROR;
+        }
+        break;
+      }
+      else
+      {
+    	CLog::Log(LOGERROR, "CHisiVideoCodec::Decode, HI_UNF_AVPLAY_GetBuf failed(0x%x)", s32Res);
+    	rtn |= VC_ERROR;
+        usleep(RW_WAIT_TIME);
+      }
+    } //for (Retry = 0; Retry < 10; Retry++)
+  } //if (pData)
+
+  //Wait for a decoded picture
+  HI_UNF_AVPLAY_STATUS_INFO_S stStatusInfo;
+  s32Res = m_dll_mpi->HI_UNF_AVPLAY_GetStatusInfo(m_hAvplay, &stStatusInfo);
+  if (s32Res == HI_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "CHisiVideoCodec::Decode, stStatusInfo.enRunStatus=%d, u32VidFrameCount=%d, u32VidErrorFrameCount=%d, u32AudFrameCount=%d",
+    		stStatusInfo.enRunStatus,
+    		stStatusInfo.u32VidFrameCount,
+    		stStatusInfo.u32VidErrorFrameCount,
+    		stStatusInfo.u32AuddFrameCount);
+
+    if (stStatusInfo.u32VidFrameCount > u32VidFrameCount)
+    {
+      u32VidFrameCount = stStatusInfo.u32VidFrameCount;
+      rtn |= VC_PICTURE;
+    }
+
+    CLog::Log(LOGERROR, "CHisiVideoCodec::Decode, stStatusInfo.stSyncStatus.u32FirstAudPts=%d, u32FirstVidPts=%d, u32LastAudPts=%d, u32LastVidPts=%d",
+    		stStatusInfo.stSyncStatus.u32FirstAudPts,
+    		stStatusInfo.stSyncStatus.u32FirstVidPts,
+    		stStatusInfo.stSyncStatus.u32LastAudPts,
+    		stStatusInfo.stSyncStatus.u32LastVidPts);
+    CLog::Log(LOGERROR, "CHisiVideoCodec::Decode, stStatusInfo.stSyncStatus.s32DiffAvPlayTime=%d, u32PlayTime=%d, u32LocalTime=%d",
+			stStatusInfo.stSyncStatus.s32DiffAvPlayTime,
+			stStatusInfo.stSyncStatus.u32PlayTime,
+			stStatusInfo.stSyncStatus.u32LocalTime);
+
+    CLog::Log(LOGERROR, "CHisiVideoCodec::Decode, stStatusInfo.stBufStatus.u32BufSize=%d, u32BufRptr=%d, u32BufWptr=%d, u32UsedSize=%d",
+    		stStatusInfo.stBufStatus[HI_UNF_AVPLAY_BUF_ID_ES_VID].u32BufSize,
+    		stStatusInfo.stBufStatus[HI_UNF_AVPLAY_BUF_ID_ES_VID].u32BufRptr,
+    		stStatusInfo.stBufStatus[HI_UNF_AVPLAY_BUF_ID_ES_VID].u32BufWptr,
+    		stStatusInfo.stBufStatus[HI_UNF_AVPLAY_BUF_ID_ES_VID].u32UsedSize);
+    CLog::Log(LOGERROR, "CHisiVideoCodec::Decode, stStatusInfo.stBufStatus.u32FrameBufTime=%d, u32FrameBufNum=%d, bEndOfStream=%d",
+    		stStatusInfo.stBufStatus[HI_UNF_AVPLAY_BUF_ID_ES_VID].u32FrameBufTime,
+    		stStatusInfo.stBufStatus[HI_UNF_AVPLAY_BUF_ID_ES_VID].u32FrameBufNum,
+    		stStatusInfo.stBufStatus[HI_UNF_AVPLAY_BUF_ID_ES_VID].bEndOfStream);
+  }
+
+  HI_UNF_AVPLAY_STREAM_INFO_S stStreamInfo;
+  s32Res = m_dll_mpi->HI_UNF_AVPLAY_GetStreamInfo(m_hAvplay, &stStreamInfo);
+  if (s32Res == HI_SUCCESS)
+  {
+	  CLog::Log(LOGERROR, "CHisiVideoCodec::Decode, stStreamInfo.stVidStreamInfo.enVCodecType=%d, u32bps=%d, u32fpsInteger=%d, u32fpsDecimal=%d",
+			  stStreamInfo.stVidStreamInfo.enVCodecType,
+			  stStreamInfo.stVidStreamInfo.u32bps,
+			  stStreamInfo.stVidStreamInfo.u32fpsInteger,
+			  stStreamInfo.stVidStreamInfo.u32fpsDecimal);
+
+	  CLog::Log(LOGERROR, "CHisiVideoCodec::Decode, stStreamInfo.stVidStreamInfo.u32Width=%d, u32Height=%d, u32DisplayWidth=%d, u32DisplayHeight=%d",
+			  stStreamInfo.stVidStreamInfo.u32Width,
+			  stStreamInfo.stVidStreamInfo.u32Height,
+			  stStreamInfo.stVidStreamInfo.u32DisplayWidth,
+			  stStreamInfo.stVidStreamInfo.u32DisplayHeight);
+  }
+
+#else
+  //6b3600
+  if (!(hisi_private->video_format == VFORMAT_VC1 &&
+    hisi_private->video_codec_type == VIDEO_DEC_FORMAT_WMV3))
+  {
+    if(hisi_private->m_preloading_done == 0)
+    {
+      pre_v_header_feeding(hisi_private, &hisi_private->hisi_pkt);
+      hisi_private->m_preloading_done = 1;
+    }
+  }
+
+  g_m_hvwait = 0;
+
+  if (pData)
+  {
+    hisi_private->hisi_pkt.data       = pData;
+    hisi_private->hisi_pkt.data_size  = size;
+    hisi_private->hisi_pkt.newflag    = 1;
+    hisi_private->hisi_pkt.isvalid    = 1;
+    hisi_private->hisi_pkt.avduration = 0;
+
+    hisi_private->hisi_pkt.avpts = AV_NOPTS_VALUE;
+#if 0 //Spitzbube: TODO
+    if (pts && pts != DVD_NOPTS_VALUE)
+    {
+      if(m_cur_pts > 0 && m_cur_pts < 40000000000.0 && (pts -m_cur_pts) > 2000000)
+      //if(m_cur_pts > 0 && m_cur_pts < 40000000000.0 && (pts -m_cur_pts) > 800000)
+      {
+         double timeout = pts -m_cur_pts - 1550000;
+         //double timeout = pts -m_cur_pts - 550000;
+
+         timeout /= PTS_FREQ;
+         timeout *= DVD_TIME_BASE;
+
+         if(timeout < 10000000/*5000000*/)
+         {
+           CLog::Log(LOGDEBUG, "CDVDPlayerVideo - WAIT DECODE(%f)(%f)(%f)", pts, m_cur_pts, timeout);
+
+           g_m_hvwait = timeout;
+
+           timeout += CDVDClock::GetAbsoluteClock();
+
+           while(!m_bStop && CDVDClock::GetAbsoluteClock() < timeout)
+             Sleep(1);
+
+           g_m_hvwait = 0;
+         }
+         else
+           m_cur_pts = pts;
+	  }
+
+	  hisi_private->hisi_pkt.avpts = pts;
+    }
+#endif //Spitzbube: TODO
+
+    hisi_private->hisi_pkt.avdts = AV_NOPTS_VALUE;
+#if 0 //Spitzbube: TODO
+    if (dts && dts != DVD_NOPTS_VALUE && pts == DVD_NOPTS_VALUE)
+    {
+      if(m_cur_pts > 0 && m_cur_pts < 40000000000.0 && (dts -m_cur_pts) > 2000000)
+      //if(m_cur_pts > 0 && m_cur_pts < 40000000000.0 && (dts -m_cur_pts) > 800000)
+      {
+         double timeout = dts -m_cur_pts - 1550000;
+         //double timeout = dts -m_cur_pts - 550000;
+
+         timeout /= PTS_FREQ;
+         timeout *= DVD_TIME_BASE;
+
+         if(timeout < 10000000/*5000000*/)
+         {
+           CLog::Log(LOGDEBUG, "CDVDPlayerVideo - WAIT DECODE(%f)(%f)(%f)", dts, m_cur_pts, timeout);
+
+           g_m_hvwait = timeout;
+
+           timeout += CDVDClock::GetAbsoluteClock();
+           while(!m_bStop && CDVDClock::GetAbsoluteClock() < timeout)
+             Sleep(1);
+
+           g_m_hvwait = 0;
+         }
+         else
+           m_cur_pts = dts;
+      }
+
+      hisi_private->hisi_pkt.avdts = dts;
+    }
+#endif //Spitzbube: TODO
+
+    //CLog::Log(LOGDEBUG, "m_hints: video pts(%f), dts(%f)", pts, dts);
+    //CLog::Log(LOGDEBUG, "m_hints: audio dts(%f), pts(%f)", g_m_hadts, g_m_hapts);
+    /*
+    if ((int64_t)INT64_0 != hisi_private->hisi_pkt.avpts)
+      CLog::Log(LOGDEBUG, "CHisiVideoCodec::Decode: pts(%f), avpts(%lld)", pts, hisi_private->hisi_pkt.avpts);
+    else
+      CLog::Log(LOGDEBUG, "CHisiVideoCodec::Decode: dts(%f), avdts(%lld)", dts, hisi_private->hisi_pkt.avdts);
+    */
+    //CLog::Log(LOGDEBUG, "CHisiVideoCodec::Decode: dts(%f), pts(%f), avdts(%lld), avpts(%lld)",
+    //  dts, pts, hisi_private->hisi_pkt.avdts, hisi_private->hisi_pkt.avpts);
+
+    set_v_header_info(hisi_private);
+    write_v_packet(hisi_private, &hisi_private->hisi_pkt);
+
+#if 0 //Spitzbube: TODO
+    // if we seek, then GetTimeSize is wrong as
+    // reports lastpts - cur_pts and hw decoder has
+    // not started outputing new pts values yet.
+    // so we grab the 1st pts sent into driver and
+    // use that to calc GetTimeSize.
+    if (m_1st_pts == 0)
+    {
+      CLog::Log(LOGDEBUG, "video lastpts: (%f)(%f)", hisi_private->hisi_pkt.lastpts, m_1st_pts);
+      m_1st_pts = hisi_private->hisi_pkt.lastpts;
+    }
+#endif
+  } //if (pData)
+  else
+  	return 0;
+
+#if 0 //Spitzbube: TODO
+  // keep hw buffered demux above 1 second
+  if (GetTimeSize() < 1.0)
+  {
+    	//CLog::Log(LOGDEBUG, "GetTimeSize: underflow (%f)(%f)", hisi_private->hisi_pkt.lastpts, m_cur_pts);
+       rtn = VC_BUFFER;
+       //return VC_BUFFER;
+  }
+
+  // wait until we get a new frame or 100ms,
+  //m_ready_event.WaitMSec(100);
+  Sleep(1);
+
+  // we must return VC_BUFFER or VC_PICTURE,
+  // default to VC_BUFFER.
+  //rtn = VC_BUFFER;
+  if (m_old_pictcnt != m_cur_pictcnt)
+  {
+    m_old_pictcnt = m_cur_pictcnt;
+    rtn |= VC_PICTURE;
+    // we got a new pict, try and keep hw buffered demux above 2 seconds.
+    // this, combined with the above 1 second check, keeps hw buffered demux between 1 and 2 seconds.
+    // we also check to make sure we keep from filling hw buffer.
+    if (GetTimeSize() < 2.0 && GetDataSize() < m_vbufsize/3)
+      rtn |= VC_BUFFER;
+  }
+/*
+  CLog::Log(LOGDEBUG, "CHisiVideoCodec::Decode: "
+    "rtn(%d), m_cur_pictcnt(%lld), m_cur_pts(%f), lastpts(%f), GetTimeSize(%f), GetDataSize(%d)",
+    rtn, m_cur_pictcnt, (float)m_cur_pts/PTS_FREQ, (float)hisi_private->hisi_pkt.lastpts/PTS_FREQ, GetTimeSize(), GetDataSize());
+*/
+#else
+  rtn |= VC_PICTURE;
+#endif //Spitzbube: TODO
+
+  rtn |= VC_BUFFER;
+
+#endif
+
+  CLog::Log(LOGDEBUG, "CHisiVideoCodec::Decode << rtn=0x%x", rtn);
+
+  return rtn;
+}
+
+void CHisiVideoCodec::SetSpeed(int speed)
+{
+  CLog::Log(LOGDEBUG, "CHisiVideoCodec::SetSpeed, speed(%d)", speed);
+
+  // update internal vars regardless
+  // of if we are open or not.
+  m_speed = speed;
+
+  if (!m_opened)
+    return;
+
+  switch(speed)
+  {
+    case DVD_PLAYSPEED_PAUSE:
+      CLog::Log(LOGDEBUG, "CHisiVideoCodec::SetSpeed, Video Pause");
+      PauseResume(1);
+	  //m_dll_mpi->HI_UNF_VO_SetWindowEnable(m_hWin, HI_FALSE);
+      break;
+    case DVD_PLAYSPEED_NORMAL:
+      CLog::Log(LOGDEBUG, "CHisiVideoCodec::SetSpeed, Video Resume");
+      PauseResume(2);
+	  //m_dll_mpi->HI_UNF_VO_SetWindowEnable(m_hWin, HI_TRUE);
+      break;
+    default:
+      HI_UNF_AVPLAY_STOP_OPT_S Stop;
+      Stop.enMode = HI_UNF_AVPLAY_STOP_MODE_BLACK;
+      Stop.u32TimeoutMs = 0;
+      CLog::Log(LOGDEBUG, "CHisiVideoCodec::SetSpeed, Video Stop");
+      m_dll_mpi->HI_UNF_AVPLAY_Stop(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_VID, &Stop);
+      break;
+  }
+}
+
+bool CHisiVideoCodec::GetPicture(DVDVideoPicture *pDvdVideoPicture)
+{
+  if (!m_opened)
+    return false;
+#if 0
+  double clock_pts = 0.0;
+  HI_UNF_AVPLAY_STATUS_INFO_S stStatusInfo;
+  if(m_dll_mpi->HI_UNF_AVPLAY_GetStatusInfo(m_hAvplay, &stStatusInfo) == HI_SUCCESS)
+  {
+     clock_pts = (double)stStatusInfo.stSyncStatus.u32LastVidPts;
+     //clock_pts = (double)stStatusInfo.stSyncStatus.u32LastVidPts / 1000;
+  }
+#endif
+
+  pDvdVideoPicture->iFlags = DVP_FLAG_ALLOCATED;
+  pDvdVideoPicture->format = RENDER_FMT_BYPASS;
+#if 0 //Spitzbube: TODO
+  pDvdVideoPicture->iDuration = (double)(hisi_private->video_rate * DVD_TIME_BASE) / UNIT_FREQ;
+  //pDvdVideoPicture->iDuration = (double)(1000 / 24);
+
+//CLog::Log(LOGDEBUG, "iDuration %f", pDvdVideoPicture->iDuration);
+
+  pDvdVideoPicture->dts = DVD_NOPTS_VALUE;
+  //pDvdVideoPicture->pts = GetPlayerPtsSeconds();
+  //pDvdVideoPicture->pts = (double)(GetPlayerPtsSeconds() * DVD_TIME_BASE) / UNIT_FREQ;;
+  pDvdVideoPicture->pts = GetPlayerPtsSeconds() * (double)DVD_TIME_BASE;
+  //pDvdVideoPicture->pts = clock_pts * (double)1000;
+  // video pts cannot be late or dvdplayer goes nuts,
+  // so run it one frame ahead
+  pDvdVideoPicture->pts += 2 * pDvdVideoPicture->iDuration;
+  //pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
+
+//CLog::Log(LOGDEBUG, "g-pts %f", pDvdVideoPicture->pts);
+#endif //Spitzbube
+
+  return true;
+}
+
+
+void CHisiVideoCodec::Reset()
+{
+  CLog::Log(LOGDEBUG, "CHisiVideoCodec::Reset");
+
+  if (!m_opened)
+	return;
+
+  // set the system blackout_policy to leave the last frame showing
+  //int blackout_policy = aml_get_sysfs_int("/sys/class/video/blackout_policy");
+  //aml_set_sysfs_int("/sys/class/video/blackout_policy", 0);
+
+  // reset the decoder
+  //m_dll->codec_reset(&hisi_private->vcodec);
+#if 0
+  // re-init our hisi_pkt
+  hisi_packet_release(&hisi_private->hisi_pkt);
+  hisi_packet_init(&hisi_private->hisi_pkt);
+  hisi_private->hisi_pkt.codec = &hisi_private->vcodec;
+#endif
+
+  if(m_speed != DVD_PLAYSPEED_NORMAL)
+  {
+	CLog::Log(LOGDEBUG, "CHisiVideoCodec::Reset - Video Reset");
+
+	g_m_hvsync = 0;
+
+	m_1st_pts = 0;
+	m_cur_pts = 0;
+	m_cur_pictcnt = 0;
+	m_old_pictcnt = 0;
+
+	m_dll_mpi->HI_UNF_AVPLAY_Start(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_VID, HI_NULL);
+	//m_dll_mpi->HI_UNF_VO_SetWindowEnable(m_hWin, HI_TRUE);
+
+	// reset some interal vars
+	hisi_private->m_preloading_done = 0;
+  }
+}
+
+int CHisiVideoCodec::GetDataSize()
+{
+  if (!m_opened)
+    return 0;
+  HI_UNF_AVPLAY_STATUS_INFO_S stStatusInfo;
+  struct buf_status vbuf ={0};
+  if(m_dll_mpi->HI_UNF_AVPLAY_GetStatusInfo(m_hAvplay, &stStatusInfo) == HI_SUCCESS)
+  {
+  	m_vbufsize = stStatusInfo.stBufStatus[HI_UNF_AVPLAY_BUF_ID_ES_VID].u32BufSize;
+	vbuf.size = stStatusInfo.stBufStatus[HI_UNF_AVPLAY_BUF_ID_ES_VID].u32BufSize;
+	vbuf.data_len = stStatusInfo.stBufStatus[HI_UNF_AVPLAY_BUF_ID_ES_VID].u32UsedSize;
+  }
+  //if (m_dll->codec_get_vbuf_state(&hisi_private->vcodec, &vbuf) >= 0)
+  //  m_vbufsize = vbuf.size;
+  return vbuf.data_len;
+}
+
+double CHisiVideoCodec::GetTimeSize()
+{
+  if (!m_opened)
+    return 0.0;
+
+  // if m_cur_pts is zero, hw decoder was not started yet
+  // so we use the pts of the 1st demux packet that was send
+  // to hw decoder to calc timesize.
+  if (m_cur_pts == 0 || fabs(m_cur_pts-m_1st_pts)/PTS_FREQ > 100)
+  {
+    m_timesize = (double)(hisi_private->hisi_pkt.lastpts - m_1st_pts) / PTS_FREQ;
+//CLog::Log(LOGDEBUG, "GetTimeSize: lastpts(%f), m_1st_pts(%f), m_timesize(%f)", hisi_private->hisi_pkt.lastpts, m_1st_pts, m_timesize);
+  }
+  else
+  {
+    m_timesize = (double)(hisi_private->hisi_pkt.lastpts - m_cur_pts) / PTS_FREQ;
+//CLog::Log(LOGDEBUG, "GetTimeSize: lastpts(%f), m_cur_pts(%f), m_timesize(%f)", hisi_private->hisi_pkt.lastpts, m_cur_pts, m_timesize);
+  }
+  // lie to DVDPlayer, it is hardcoded to a max of 8 seconds,
+  // if you buffer more than 8 seconds, it goes nuts.
+  double timesize = m_timesize;
+  if (timesize < 0.0)
+    timesize = 0.0;
+  else if (timesize > 7.0)
+    timesize = 7.0;
+
+  return timesize;
+}
+
+void CHisiVideoCodec::Process()
+{
+  HI_S32 s32Res;
+
+  CLog::Log(LOGDEBUG, "CHisiVideoCodec::Process Started");
+
+#if 0 //Spitzbube: TODO
+  SetPriority(THREAD_PRIORITY_ABOVE_NORMAL);
+#endif
+
+  while (!m_bStop)
+  {
+#if 0 //Spitzbube: TODO
+    double pts_video = 0.0;
+    double duration = 0.0;
+    double pts_diff = 0.0;
+
+    //6b5390
+	if (hisi_private->hisi_pkt.lastpts > 0)
+	{
+	  //6b53a4
+	  // this is a blocking poll that returns every vsync.
+	  // since we are running at a higher priority, make sure
+	  // we sleep if the call fails or does a timeout.
+#if 0
+	  if (m_dll->codec_poll_cntl(&hisi_private->vcodec) < 0)
+	  {
+		CLog::Log(LOGDEBUG, "CHisiVideoCodec::Process: codec_poll_cntl failed");
+		Sleep(10);
+	  }
+#endif
+	  if (g_application.m_pPlayer && g_application.m_pPlayer->IsPlaying())
+	  {
+		//CLog::Log(LOGDEBUG, "CHisiVideoCodec::Process: IsPlaying");
+		/*
+		if (g_application.m_pPlayer->IsPaused())
+		  PauseResume(1);
+		else
+		  PauseResume(2);
+		*/
+		Sleep(10);
+	  }
+
+      //m_dll_mpi->HI_UNF_SND_SetMute(HI_UNF_SND_0, (HI_BOOL)g_settings.m_bMute);
+
+	  //6b53e4
+	  HI_UNF_AVPLAY_STATUS_INFO_S stStatusInfo; //sp4;
+	  s32Res = m_dll_mpi->HI_UNF_AVPLAY_GetStatusInfo(m_hAvplay, &stStatusInfo);
+	  if (s32Res == HI_SUCCESS)
+	  {
+		//6b5404
+        pts_video = stStatusInfo.stSyncStatus.u32LastVidPts;
+        pts_video *= PTS_FREQ_MS;
+	  }
+	  else
+	  {
+		//6b54ac
+		CLog::Log(LOGERROR, "CHisiVideoCodec::Process: no pts_video(%f)", m_cur_pts);
+		pts_video = m_cur_pts + 1000;
+		//->6b5410
+      }
+      //pts_video = get_pts_video();
+      if (pts_video && m_cur_pts != pts_video)
+      {
+        duration = (double)(pts_video - m_cur_pts)/PTS_FREQ;
+
+        //CLog::Log(LOGDEBUG, "CHisiVideoCodec::Process: pts_video(%f), duration(%f)", pts_video, (double)(pts_video - m_cur_pts)/PTS_FREQ);
+        // other threads look at these, do them first
+        m_cur_pts = pts_video;
+        m_cur_pictcnt++;
+        //m_ready_event.Set();
+
+        if(pts_video < 40000000000.0)
+        {
+          double app_pts = GetPlayerPtsSeconds();
+          // add in audio delay/display latency contribution
+          double offset  = g_renderManager.GetDisplayLatency() - CMediaSettings::Get().GetCurrentVideoSettings().m_AudioDelay;
+          // correct video pts by user set delay and rendering delay
+          app_pts += offset;
+
+          g_m_hvsync = m_cur_pts;
+
+          pts_diff = pts_video/PTS_FREQ - app_pts;
+
+          if (fabs(pts_diff) > 0.2 && duration > 0)
+          {
+#if 0
+             CLog::Log(LOGDEBUG, "CHisiVideoCodec::voffset(%f)(%f)(%f)", pts_diff, pts_video, app_pts);
+	      if(pts_diff > 0)
+               SetVideoPtsSeconds(pts_video - 100*PTS_FREQ_MS);
+	      else
+               SetVideoPtsSeconds(pts_video + 100*PTS_FREQ_MS);
+#endif
+          }
+      	}
+      }
+	} //if (hisi_private->hisi_pkt.lastpts > 0)
+	else
+	{
+	  //6b549c
+      Sleep(10);
+	}
+#else //Spitzbube: TODO
+	Sleep(100);
+#endif
+  } //while (!m_bStop)
+  //6b5474
+#if 0 //Spitzbube: TODO
+  SetPriority(THREAD_PRIORITY_NORMAL);
+#endif
+
+  CLog::Log(LOGDEBUG, "CHisiVideoCodec::Process Stopped");
+}
+
+void CHisiVideoCodec::PauseResume(int state)
+{
+  if (state == -1)
+    return;
+  if (state == 1)
+    m_dll_mpi->HI_UNF_AVPLAY_Pause(m_hAvplay, NULL);
+  else
+    m_dll_mpi->HI_UNF_AVPLAY_Resume(m_hAvplay, NULL);
+}
+
+double CHisiVideoCodec::GetPlayerPtsSeconds()
+{
+#if 0 //Spitzbube: TODO
+  double clock_pts = 0.0;
+
+#if 1
+  extern CDVDClock* g_m_hClock;
+  CDVDClock *playerclock = g_m_hClock;
+  if (playerclock)
+    clock_pts = playerclock->GetClock() / DVD_TIME_BASE;
+#else
+  HI_UNF_AVPLAY_STATUS_INFO_S stStatusInfo;
+  if(m_dll_mpi->HI_UNF_AVPLAY_GetStatusInfo(m_hAvplay, &stStatusInfo) == HI_SUCCESS)
+  {
+     //clock_pts = (double)stStatusInfo.stSyncStatus.u32LastVidPts * 1000;
+     clock_pts = (double)stStatusInfo.stSyncStatus.u32LastVidPts / 1000;
+  }
+#endif
+
+  return clock_pts;
+#endif //Spitzbube: TODO
+}
+
+void CHisiVideoCodec::SetVideoRect(const CRect &SrcRect, const CRect &DestRect)
+{
+  // this routine gets called every video frame
+  // and is in the context of the renderer thread so
+  // do not do anything stupid here.
+
+  // video zoom adjustment.
+  float zoom = CMediaSettings::Get().GetCurrentVideoSettings().m_CustomZoomAmount;
+  if ((int)(zoom * 1000) != (int)(m_zoom * 1000))
+  {
+	m_zoom = zoom;
+  }
+  // video contrast adjustment.
+  int contrast = CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast;
+  if (contrast != m_contrast)
+  {
+#if 0 //Spitzbube: TODO
+	SetVideoContrast(contrast);
+#endif
+	m_contrast = contrast;
+  }
+  // video brightness adjustment.
+  int brightness = CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness;
+  if (brightness != m_brightness)
+  {
+#if 0 //Spitzbube: TODO
+	SetVideoBrightness(brightness);
+#endif
+	m_brightness = brightness;
+  }
+
+/*
+  CLog::Log(LOGDEBUG, "CHisiVideoCodec::SrcRect: %d,%d,%d,%d",
+	(int)SrcRect.x1, (int)SrcRect.y1, (int)SrcRect.x2, (int)SrcRect.y2);
+  CLog::Log(LOGDEBUG, "CHisiVideoCodec::DestRect: %d,%d,%d,%d",
+	(int)DestRect.x1, (int)DestRect.y1, (int)DestRect.x2, (int)DestRect.y2);
+*/
+
+  // check if destination rect or video view mode has changed
+  if ((m_dst_rect != DestRect) || (m_view_mode != CMediaSettings::Get().GetCurrentVideoSettings().m_ViewMode))
+  {
+	m_dst_rect  = DestRect;
+	m_view_mode = CMediaSettings::Get().GetCurrentVideoSettings().m_ViewMode;
+  }
+  else
+  {
+	// mainvideo 'should' be showing already if we get here, make sure.
+	//ShowMainVideo(true);
+	m_dll_mpi->HI_UNF_VO_SetWindowEnable(m_hWin, HI_TRUE);
+	return;
+  }
+
+  CRect gui, display, dst_rect;
+
+  gui = g_graphicsContext.GetViewWindow();
+  // when display is at 1080p, we have freescale enabled
+  // and that scales all layers into 1080p display including video,
+  // so we have to setup video axis for 720p instead of 1080p... Boooo.
+  display = g_graphicsContext.GetViewWindow();
+  //RESOLUTION res = g_graphicsContext.GetVideoResolution();
+  display.SetRect(0, 0, CDisplaySettings::Get().GetCurrentResolutionInfo().iScreenWidth, CDisplaySettings::Get().GetCurrentResolutionInfo().iScreenHeight);
+  dst_rect = m_dst_rect;
+
+#if 1
+  dst_rect.x1 = dst_rect.x1 * 1920 / 1280;
+  dst_rect.x2 = dst_rect.x2 * 1920 / 1280;
+  dst_rect.y1 = dst_rect.y1 * 1080 /  720;
+  dst_rect.y2 = dst_rect.y2 * 1080 /  720;
+
+#else
+  if (gui != display)
+  {
+	float xscale = display.Width() / gui.Width();
+	float yscale = display.Height() / gui.Height();
+	dst_rect.x1 *= xscale;
+	dst_rect.x2 *= xscale;
+	dst_rect.y1 *= yscale;
+	dst_rect.y2 *= yscale;
+  }
+#endif
+
+  m_dll_mpi->HI_UNF_VO_SetWindowEnable(m_hWin, HI_FALSE);
+  //ShowMainVideo(false);
+
+  // goofy 0/1 based difference in aml axis coordinates.
+  // fix them.
+#if 0
+  dst_rect.x2--;
+  dst_rect.y2--;
+#endif
+#if 0
+  char video_axis[256] = {0};
+  sprintf(video_axis, "%d %d %d %d", (int)dst_rect.x1, (int)dst_rect.y1, (int)dst_rect.x2, (int)dst_rect.y2);
+  aml_set_sysfs_str("/sys/class/video/axis", video_axis);
+#endif
+
+  std::string rectangle;
+  StringUtils::Format("%i,%i,%i,%i",
+	(int)dst_rect.x1, (int)dst_rect.y1,
+	(int)dst_rect.Width(), (int)dst_rect.Height());
+  CLog::Log(LOGDEBUG, "CHisiVideoCodec::SetVideoRect:dst_rect(%s)", rectangle.c_str());
+
+  // we only get called once gui has changed to something
+  // that would show video playback, so show it.
+  //ShowMainVideo(true);
+  m_dll_mpi->HI_UNF_VO_SetWindowEnable(m_hWin, HI_TRUE);
+}
+
+/* static */
+void CHisiVideoCodec::RenderUpdateCallBack(const void *ctx, const CRect &SrcRect, const CRect &DestRect)
+{
+  //6b585c
+  CHisiVideoCodec *codec = (CHisiVideoCodec*)ctx;
+  codec->SetVideoRect(SrcRect, DestRect);
+}
+
diff -Naur kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Video/HisiVideoCodec.h kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Video/HisiVideoCodec.h
--- kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Video/HisiVideoCodec.h	1970-01-01 01:00:00.000000000 +0100
+++ kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Video/HisiVideoCodec.h	2016-04-15 19:52:46.626020314 +0200
@@ -0,0 +1,165 @@
+
+#pragma once
+/*
+ *      Copyright (C) 2005-2011 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "DVDVideoCodec.h"
+#include "DVDStreamInfo.h"
+#include "threads/Thread.h"
+#include "threads/CriticalSection.h"
+#include "threads/Condition.h"
+#include "guilib/Geometry.h"
+#include "hi_common.h"
+#include "hi_unf_video.h"
+
+
+
+typedef enum {
+    STREAM_TYPE_UNKNOW,
+    STREAM_TYPE_ES_VIDEO,
+    STREAM_TYPE_ES_AUDIO,
+    STREAM_TYPE_ES_SUB,
+    STREAM_TYPE_PS,
+    STREAM_TYPE_TS,
+    STREAM_TYPE_RM,
+} stream_type_t;
+
+typedef struct {
+    unsigned int    format;  ///< video format, such as H264, MPEG2...
+    unsigned int    width;   ///< video source width
+    unsigned int    height;  ///< video source height
+    unsigned int    rate;    ///< video source frame duration
+    unsigned int    extra;   ///< extra data information of video stream
+    unsigned int    status;  ///< status of video stream
+    unsigned int    ratio;   ///< aspect ratio of video source
+    void *          param; //228  ///< other parameters for video decoder
+    unsigned long long ratio64; ///< aspect ratio of video source
+} dec_sysinfo_t;
+
+typedef struct {
+#if 0 //Spitzbube: TODO
+    CODEC_HANDLE handle;        ///< codec device handler
+    CODEC_HANDLE cntl_handle;   ///< video control device handler
+    CODEC_HANDLE sub_handle;    ///< subtile device handler
+#endif
+    stream_type_t stream_type;  ///< stream type(es, ps, rm, ts)
+    unsigned int has_video:1;   ///< stream has video(1) or not(0)
+#if 0
+    unsigned int has_audio:1;   ///< stream has audio(1) or not(0)
+    unsigned int has_sub:1;     ///< stream has subtitle(1) or not(0)
+#endif
+    unsigned int noblock:1;     ///< codec device is NONBLOCK(1) or not(0)
+    int video_type;             ///< stream video type(H264, VC1...)
+#if 0
+    int audio_type;             ///< stream audio type(PCM, WMA...)
+    int sub_type;               ///< stream subtitle type(TXT, SSA...)
+#endif
+    int video_pid;              ///< stream video pid
+#if 0
+    int audio_pid;              ///< stream audio pid
+    int sub_pid;                ///< stream subtitle pid
+    int audio_channels;         ///< stream audio channel number
+    int audio_samplerate;       ///< steram audio sample rate
+    int vbuf_size;              ///< video buffer size of codec device
+    int abuf_size;              ///< audio buffer size of codec device
+#endif
+    dec_sysinfo_t hisi_sysinfo;   ///< system information for video
+#if 0
+    audio_info_t audio_info;    ///< audio information pass to audiodsp
+    int packet_size;            ///< data size per packet
+    int avsync_threshold;       ///<for adec in ms>
+#endif
+    void * adec_priv;           ///<for adec>
+} codec_para_t;
+
+typedef struct hisi_private_t hisi_private_t;
+
+class DllLibHiSample;
+class DllLibHiComm;
+class DllLibHiMpi;
+
+class CHisiVideoCodec : public CThread
+{
+public:
+  CHisiVideoCodec();
+  virtual ~CHisiVideoCodec();
+
+  bool OpenDecoder(CDVDStreamInfo &hints);
+  void CloseDecoder();
+
+  int Decode(uint8_t* pData, int iSize, double dts, double pts);
+  bool GetPicture(DVDVideoPicture* pDvdVideoPicture);
+  void          SetSpeed(int speed);
+  int           GetDataSize();
+  double        GetTimeSize();
+  void Reset();
+
+protected:
+  virtual void  Process();
+
+private:
+  void          PauseResume(int state);
+  double        GetPlayerPtsSeconds();
+  void SetVideoRect(const CRect &SrcRect, const CRect &DestRect);
+  static void RenderUpdateCallBack(const void *ctx, const CRect &SrcRect, const CRect &DestRect);
+
+protected:
+  //bool m_bStop; //4 //CThread
+  DllLibHiSample* m_dll_sample; //176
+  DllLibHiComm* m_dll_comm; //180
+  DllLibHiMpi* m_dll_mpi; //184
+  hisi_private_t* hisi_private; //188
+  volatile double m_1st_pts;
+  volatile double m_cur_pts; //200
+  volatile double m_cur_pictcnt;
+  volatile double m_old_pictcnt;
+  volatile double  m_timesize;
+  volatile int m_vbufsize;
+
+#if 1
+  //CEvent        m_ready_event;
+#else
+  char m_bData_236; //236
+  char m_bData_237; //237
+  int m_Data_240; //240
+  CCriticalSection m_Section_244; //244
+  XbmcThreads::ConditionVariable m_Cond_256; //256
+  CCriticalSection m_Section_268; //268
+#endif
+
+  CRect         m_dst_rect;
+  CRect         m_dst_rect_prev;
+  int           m_view_mode;
+  float         m_zoom;
+  int           m_contrast;
+  int           m_brightness;
+
+  HI_UNF_VCODEC_TYPE_E m_VdecType; //324
+  HI_HANDLE m_hAvplay; //328
+  HI_HANDLE m_hWin; //332
+  int           m_speed;
+  bool m_opened; //344
+
+  HI_U32 u32VidFrameCount;
+
+//  static HI_HANDLE g_m_hAvplay;
+};
+
diff -Naur kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
--- kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in	2015-10-23 23:53:21.000000000 +0200
+++ kodi.work/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in	2016-04-09 09:48:00.231019908 +0200
@@ -41,6 +41,12 @@
 SRCS += MMALCodec.cpp
 endif
 
+ifeq (@USE_LIBHISICODEC@,1) 
+SRCS += DllLibHiSample.cpp
+SRCS += HisiVideoCodec.cpp
+SRCS += DVDVideoCodecHisi.cpp
+endif
+
 LIB=Video.a
 
 include @abs_top_srcdir@/Makefile.include
diff -Naur kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp kodi.work/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp
--- kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp	2015-10-23 23:53:21.000000000 +0200
+++ kodi.work/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp	2016-04-13 14:28:45.739732076 +0200
@@ -44,6 +44,13 @@
 
 using namespace std;
 
+#undef HAS_LIBHISICODEC
+
+#if defined(HAS_LIBHISICODEC)
+extern double g_m_hvsync;
+extern double g_m_hasync;
+#endif
+
 void CPTSInputQueue::Add(int64_t bytes, double pts)
 {
   CSingleLock lock(m_sync);
@@ -263,7 +270,47 @@
       if (dts != DVD_NOPTS_VALUE)
         m_audioClock = dts;
 
+#if defined(HAS_LIBHISICODEC)
+      memset(&audioframe, 0, sizeof(DVDAudioFrame));
+      if (dts != DVD_NOPTS_VALUE)
+      {
+		#define PTS_FREQ         9000000 //90000
+
+        double pts_diff= 0.0;
+
+        g_m_hasync = dts;
+	    pts_diff = g_m_hasync - g_m_hvsync;
+
+        if (fabs(pts_diff/PTS_FREQ) > 0.2 && fabs(pts_diff/PTS_FREQ) < 0.5 && g_m_hasync > 0 && g_m_hvsync > 0)
+		{
+			CLog::Log(LOGDEBUG, "m_hints: ap(%f)(%f)(%f)", pts_diff, g_m_hvsync, g_m_hasync);
+			if(pts_diff > 0)
+			{
+				double timeout = pts_diff;
+
+				timeout /= PTS_FREQ;
+				//timeout -= 0.1;
+				timeout *= DVD_TIME_BASE;
+
+				CLog::Log(LOGDEBUG, "CDVDPlayerAudio - S/W WAIT SYNC(%f)(%f)", dts, timeout);
+
+				timeout += CDVDClock::GetAbsoluteClock();
+
+				while(!m_bStop && CDVDClock::GetAbsoluteClock() < timeout)
+					Sleep(1);
+			}
+			else
+			{
+				g_m_hasync = g_m_hvsync;
+				return 0;
+			}
+		}
+      }
+
+      int len = m_pAudioCodec->Decode(m_decode.data, m_decode.size, dts);
+#else
       int len = m_pAudioCodec->Decode(m_decode.data, m_decode.size);
+#endif
       if (len < 0 || len > m_decode.size)
       {
         /* if error, we skip the packet */
@@ -500,6 +547,185 @@
 
 void CDVDPlayerAudio::Process()
 {
+#if defined(HAS_LIBHISICODEC)
+  CLog::Log(LOGNOTICE, "running thread: CDVDPlayerAudio::H/W Codec Process()");
+
+  //int result;
+  //bool bRequestDrop = false;
+
+  m_audioStats.Start();
+
+  while (!m_bStop)
+  {
+	int iQueueTimeOut = (int)(m_stalled ? 100 / 4 : 100 * 10);
+	int iPriority = (m_speed == DVD_PLAYSPEED_PAUSE && m_started) ? 1 : 0;
+
+	CDVDMsg* pMsg;
+	MsgQueueReturnCode ret = m_messageQueue.Get(&pMsg, iQueueTimeOut, iPriority);
+
+	if (MSGQ_IS_ERROR(ret) || ret == MSGQ_ABORT)
+	{
+	  CLog::Log(LOGERROR, "Got MSGQ_ABORT or MSGO_IS_ERROR return true");
+	  break;
+	}
+	else if (ret == MSGQ_TIMEOUT)
+	{
+	  // if we only wanted priority messages, this isn't a stall
+	  if( iPriority )
+		continue;
+
+	  //Okey, start rendering at stream fps now instead, we are likely in a stillframe
+	  if( !m_stalled )
+	  {
+		m_stalled = true;
+	  }
+	  continue;
+	}
+
+	if (pMsg->IsType(CDVDMsg::DEMUXER_PACKET))
+	{
+	  DemuxPacket* pPacket = ((CDVDMsgDemuxerPacket*)pMsg)->GetPacket();
+	  //bool bPacketDrop     = ((CDVDMsgDemuxerPacket*)pMsg)->GetPacketDrop();
+
+	  if (m_stalled)
+	  {
+		m_stalled = false;
+	  }
+
+	  if (!m_silence && m_speed == DVD_PLAYSPEED_NORMAL )
+	  {
+		int len = m_pAudioCodec->Decode(pPacket->pData, pPacket->iSize, pPacket->dts);
+		m_audioStats.AddSampleBytes(pPacket->iSize);
+
+		if (len < 0)
+		{
+		  /* if error, we skip the packet */
+		  CLog::Log(LOGERROR, "CDVDPlayerAudio::DecodeFrame - Decode Error. Skipping audio packet");
+		  m_pAudioCodec->Reset();
+		}
+	  }
+
+	  //CLog::Log(LOGDEBUG, "DEMUXER_PACKET %f", m_decode.dts);
+	  // signal to our parent that we have initialized
+	  //if(m_started == false && m_speed == DVD_PLAYSPEED_NORMAL)
+	  if(m_started == false)
+	  {
+		CLog::Log(LOGDEBUG, "CDVDPlayerAudio - CDVDMsg::PLAYER_STARTED");
+		m_started = true;
+		m_messageParent.Put(new CDVDMsgInt(CDVDMsg::PLAYER_STARTED, DVDPLAYER_AUDIO));
+	  }
+	}
+	else if (pMsg->IsType(CDVDMsg::GENERAL_SYNCHRONIZE))
+	{
+	  CLog::Log(LOGDEBUG, "GENERAL_SYNC %f", m_audioClock);
+	  if(((CDVDMsgGeneralSynchronize*)pMsg)->Wait( 100, SYNCSOURCE_AUDIO ))
+		CLog::Log(LOGDEBUG, "CDVDPlayerAudio - CDVDMsg::GENERAL_SYNCHRONIZE");
+	  else
+		m_messageQueue.Put(pMsg->Acquire(), 1); /* push back as prio message, to process other prio messages */
+	}
+	else if (pMsg->IsType(CDVDMsg::GENERAL_RESYNC))
+	{
+	  //player asked us to set internal clock
+	  CDVDMsgGeneralResync* pMsgGeneralResync = (CDVDMsgGeneralResync*)pMsg;
+
+	  if (pMsgGeneralResync->m_timestamp != DVD_NOPTS_VALUE)
+	  {
+		m_audioClock = pMsgGeneralResync->m_timestamp;
+		CLog::Log(LOGDEBUG, "3-apts %f", m_audioClock);
+	  }
+	  CLog::Log(LOGDEBUG, "GENERAL_RESYNC %f", m_audioClock);
+	  if (pMsgGeneralResync->m_clock)
+	  {
+	 double playPts = m_audioClock;
+		CLog::Log(LOGDEBUG, "CDVDPlayerAudio - CDVDMsg::GENERAL_RESYNC(%f, 1)", playPts);
+		m_pClock->Discontinuity(playPts);
+	  }
+	  else
+		CLog::Log(LOGDEBUG, "CDVDPlayerAudio - CDVDMsg::GENERAL_RESYNC(%f, 0)", m_audioClock);
+	}
+	else if (pMsg->IsType(CDVDMsg::GENERAL_RESET))
+	{
+	  CLog::Log(LOGDEBUG, "GENERAL_RESET %f", m_audioClock);
+	  if (m_pAudioCodec)
+		m_pAudioCodec->Reset();
+	  m_started = false;
+	}
+	else if (pMsg->IsType(CDVDMsg::GENERAL_FLUSH))
+	{
+	  CLog::Log(LOGDEBUG, "DVDAUDIO GENERAL_FLUSH %f", m_audioClock);
+	  m_stalled   = true;
+	  m_started   = false;
+
+	  if (m_pAudioCodec)
+		m_pAudioCodec->Reset();
+	}
+	else if (pMsg->IsType(CDVDMsg::PLAYER_STARTED))
+	{
+	  CLog::Log(LOGDEBUG, "PLAYER_STARTED %f", m_audioClock);
+	  if(m_started)
+		m_messageParent.Put(new CDVDMsgInt(CDVDMsg::PLAYER_STARTED, DVDPLAYER_AUDIO));
+	}
+	else if (pMsg->IsType(CDVDMsg::PLAYER_DISPLAYTIME))
+	{
+	  CDVDPlayer::SPlayerState& state = ((CDVDMsgType<CDVDPlayer::SPlayerState>*)pMsg)->m_value;
+
+	  //CLog::Log(LOGDEBUG, "PLAYER_DISPLAYTIME a %f", m_audioClock);
+
+	  if(state.time_src == CDVDPlayer::ETIMESOURCE_CLOCK)
+		state.time      = DVD_TIME_TO_MSEC(m_pClock->GetClock(state.timestamp) + state.time_offset);
+	  else
+		state.timestamp = CDVDClock::GetAbsoluteClock();
+	  state.player    = DVDPLAYER_AUDIO;
+//CLog::Log(LOGDEBUG, "AUDIO PLAYER_DISPLAYTIME %f, %f, %f", state.time, state.timestamp, state.time_offset);
+	  m_messageParent.Put(pMsg->Acquire());
+	}
+	else if (pMsg->IsType(CDVDMsg::GENERAL_EOF))
+	{
+	  CLog::Log(LOGDEBUG, "CDVDPlayerAudio - CDVDMsg::GENERAL_EOF");
+	}
+	else if (pMsg->IsType(CDVDMsg::GENERAL_DELAY))
+	{
+	  CLog::Log(LOGDEBUG, "GENERAL_DELAY %f", m_audioClock);
+	  if (m_speed != DVD_PLAYSPEED_PAUSE)
+	  {
+		double timeout = static_cast<CDVDMsgDouble*>(pMsg)->m_value;
+
+		CLog::Log(LOGDEBUG, "CDVDPlayerAudio - CDVDMsg::GENERAL_DELAY(%f)", timeout);
+
+		timeout *= (double)DVD_PLAYSPEED_NORMAL / abs(m_speed);
+		timeout += CDVDClock::GetAbsoluteClock();
+
+		while(!m_bStop && CDVDClock::GetAbsoluteClock() < timeout)
+		  Sleep(1);
+	  }
+	}
+	else if (pMsg->IsType(CDVDMsg::PLAYER_SETSPEED))
+	{
+	  m_speed = static_cast<CDVDMsgInt*>(pMsg)->m_value;
+
+	  CLog::Log(LOGDEBUG, "PLAYER_SETSPEED Audio %d", m_speed);
+	  if (m_pAudioCodec)
+		m_pAudioCodec->SetSpeed(m_speed);
+	}
+	else if (pMsg->IsType(CDVDMsg::AUDIO_SILENCE))
+	{
+	  m_silence = static_cast<CDVDMsgBool*>(pMsg)->m_value;
+	  if (m_silence)
+		CLog::Log(LOGDEBUG, "CDVDPlayerAudio - CDVDMsg::AUDIO_SILENCE(%f, 1)", m_audioClock);
+	  else
+		CLog::Log(LOGDEBUG, "CDVDPlayerAudio - CDVDMsg::AUDIO_SILENCE(%f, 0)", m_audioClock);
+	}
+	else if (pMsg->IsType(CDVDMsg::GENERAL_STREAMCHANGE))
+	{
+	  CDVDMsgAudioCodecChange* msg(static_cast<CDVDMsgAudioCodecChange*>(pMsg));
+	  OpenStream(msg->m_hints, msg->m_codec);
+	  msg->m_codec = NULL;
+	}
+
+	pMsg->Release();
+
+  } //while (!m_bStop)
+#else
   CLog::Log(LOGNOTICE, "running thread: CDVDPlayerAudio::Process()");
 
   bool packetadded(false);
@@ -614,6 +840,7 @@
     if (packetadded)
       HandleSyncError(audioframe.duration);
   }
+#endif
 }
 
 void CDVDPlayerAudio::SetSyncType(bool passthrough)
diff -Naur kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDPlayer.cpp kodi.work/xbmc/cores/dvdplayer/DVDPlayer.cpp
--- kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDPlayer.cpp	2015-10-23 23:53:21.000000000 +0200
+++ kodi.work/xbmc/cores/dvdplayer/DVDPlayer.cpp	2016-04-09 10:55:31.223008223 +0200
@@ -84,6 +84,12 @@
 using namespace std;
 using namespace PVR;
 
+#if defined(HAS_LIBHISICODEC)
+double g_m_hvsync = 0;
+double g_m_hasync = 0;
+double g_m_hvwait = 0;
+#endif
+
 void CSelectionStreams::Clear(StreamType type, StreamSource source)
 {
   CSingleLock lock(m_section);
diff -Naur kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp kodi.work/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
--- kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp	2015-10-23 23:53:21.000000000 +0200
+++ kodi.work/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp	2016-04-13 14:16:18.746447483 +0200
@@ -41,9 +41,20 @@
 #include <iterator>
 #include "utils/log.h"
 
+#undef HAS_LIBHISICODEC
+
+#if defined(HAS_LIBHISICODEC)
+#include "DVDCodecs/Video/DVDVideoCodecHisi.h"
+#include "DVDCodecs/Audio/DVDAudioCodecHisi.h"
+#endif
+
 using namespace std;
 using namespace RenderManager;
 
+#if defined(HAS_LIBHISICODEC)
+CDVDClock* g_m_hClock;
+#endif
+
 class CPulldownCorrection
 {
 public:
@@ -127,6 +138,10 @@
   m_pOverlayContainer = pOverlayContainer;
   m_pTempOverlayPicture = NULL;
   m_pVideoCodec = NULL;
+#if defined(HAS_LIBHISICODEC)
+  m_pVideoHWCodec = NULL;
+  m_hwcodec = true;
+#endif
   m_speed = DVD_PLAYSPEED_NORMAL;
 
   m_bRenderSubs = false;
@@ -154,6 +169,9 @@
   m_bFpsInvalid = false;
   m_bAllowFullscreen = false;
   memset(&m_output, 0, sizeof(m_output));
+#if defined(HAS_LIBHISICODEC)
+  g_m_hClock = pClock;
+#endif
 }
 
 CDVDPlayerVideo::~CDVDPlayerVideo()
@@ -248,6 +266,28 @@
   m_started = false;
   m_codecname = m_pVideoCodec->GetName();
   m_packets.clear();
+
+#if defined(HAS_LIBHISICODEC)
+  if (m_pVideoHWCodec)
+    delete m_pVideoHWCodec;
+
+  CLog::Log(LOGINFO, "Hisi Video Decoder...");
+  CDVDCodecOptions options;
+  std::vector<ERenderFormat> formats;
+#ifdef HAS_VIDEO_PLAYBACK
+  //formats = g_renderManager.SupportedFormats();
+#endif
+  if(formats.size() == 0)
+    options.m_formats.push_back(RENDER_FMT_YUV420P);
+  else
+    options.m_formats = formats;
+  CDVDVideoCodec* pCodec = CDVDFactoryCodec::OpenCodec(new CDVDVideoCodecHisi(), hint, options);
+  if(pCodec)
+     m_pVideoHWCodec = pCodec;
+
+  if(m_pVideoHWCodec == NULL)
+  	 m_hwcodec = false;
+#endif
 }
 
 void CDVDPlayerVideo::CloseStream(bool bWaitForBuffers)
@@ -272,6 +312,17 @@
     m_pVideoCodec = NULL;
   }
 
+#if defined(HAS_LIBHISICODEC)
+  CLog::Log(LOGNOTICE, "deleting video h/w codec");
+  if (m_pVideoHWCodec)
+  {
+  CLog::Log(LOGNOTICE, "deleting video h/w Dispose");
+    m_pVideoHWCodec->Dispose();
+    delete m_pVideoHWCodec;
+    m_pVideoHWCodec = NULL;
+  }
+#endif
+
   if (m_pTempOverlayPicture)
   {
     CDVDCodecUtils::FreePicture(m_pTempOverlayPicture);
@@ -415,6 +466,10 @@
     {
       if(m_pVideoCodec)
         m_pVideoCodec->Reset();
+#if defined(HAS_LIBHISICODEC)
+      if(m_pVideoHWCodec)
+         m_pVideoHWCodec->Reset();
+#endif
       picture.iFlags &= ~DVP_FLAG_ALLOCATED;
       m_packets.clear();
       m_started = false;
@@ -424,6 +479,11 @@
     {
       if(m_pVideoCodec)
         m_pVideoCodec->Reset();
+#if defined(HAS_LIBHISICODEC)
+      if(m_pVideoHWCodec)
+         m_pVideoHWCodec->Reset();
+
+#endif
       picture.iFlags &= ~DVP_FLAG_ALLOCATED;
       m_packets.clear();
 
@@ -449,10 +509,47 @@
     else if (pMsg->IsType(CDVDMsg::PLAYER_SETSPEED))
     {
       m_speed = static_cast<CDVDMsgInt*>(pMsg)->m_value;
+#if defined(HAS_LIBHISICODEC)
+	  CLog::Log(LOGDEBUG, "PLAYER_SETSPEED Video %d", m_speed);
+#endif
       if(m_speed == DVD_PLAYSPEED_PAUSE)
         m_iNrOfPicturesNotToSkip = 0;
+#if defined(HAS_LIBHISICODEC)
+	  if(m_hints.codec == CODEC_ID_WMV3 || m_hints.codec == CODEC_ID_MJPEG)
+	  {
+      if(m_pVideoHWCodec)
+	     m_pVideoHWCodec->SetSpeed(m_speed);
+	  if(m_pVideoCodec)
+		 m_pVideoCodec->SetSpeed(m_speed);
+			m_hwcodec = false;
+	  }
+	  else
+	  {
+		  if(m_speed == DVD_PLAYSPEED_PAUSE || m_speed == DVD_PLAYSPEED_NORMAL)
+		  {
+		     if(m_pVideoCodec)
+			     m_pVideoCodec->SetSpeed(m_speed);
+			 if(m_pVideoHWCodec)
+			 {
+			    m_pVideoHWCodec->SetSpeed(m_speed);
+			    m_hwcodec = true;
+			 }
+			 else
+			    m_hwcodec = false;
+		  }
+		  else
+		  {
+			 if(m_pVideoHWCodec)
+			    m_pVideoHWCodec->SetSpeed(m_speed);
+		  	 if(m_pVideoCodec)
+			    m_pVideoCodec->SetSpeed(m_speed);
+			 m_hwcodec = false;
+		  }
+	  }
+#else
       if (m_pVideoCodec)
         m_pVideoCodec->SetSpeed(m_speed);
+#endif
       m_droppingStats.Reset();
     }
     else if (pMsg->IsType(CDVDMsg::PLAYER_STARTED))
@@ -528,7 +625,15 @@
         iDropped++;
       }
 
-      if (m_messageQueue.GetDataSize() == 0
+      int datasize = m_messageQueue.GetDataSize();
+  #if defined(HAS_LIBHISICODEC)
+      if (m_hwcodec == false && m_pVideoCodec)
+        datasize += m_pVideoCodec->GetDataSize();
+      else if (m_pVideoHWCodec)
+        datasize += m_pVideoHWCodec->GetDataSize();
+  #endif
+
+      if (datasize == 0
       ||  m_speed < 0)
       {
         bRequestDrop = false;
@@ -544,7 +649,14 @@
       // problem here, if one packet contains more than one frame
       // both frames will be dropped in that case instead of just the first
       // decoder still needs to provide an empty image structure, with correct flags
+#if defined(HAS_LIBHISICODEC)
+      if(m_hwcodec == true && m_pVideoHWCodec)
+         m_pVideoHWCodec->SetDropState(bRequestDrop);
+      else if(m_pVideoCodec)
+         m_pVideoCodec->SetDropState(bRequestDrop);
+#else
       m_pVideoCodec->SetDropState(bRequestDrop);
+#endif
 
       // ask codec to do deinterlacing if possible
       EDEINTERLACEMODE mDeintMode = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
@@ -566,12 +678,31 @@
       if (!g_renderManager.Supports(RENDERFEATURE_ROTATION))
         mFilters |= CDVDVideoCodec::FILTER_ROTATE;
 
+#if defined(HAS_LIBHISICODEC)
+      if(m_hwcodec == true && m_pVideoHWCodec)
+         mFilters = m_pVideoHWCodec->SetFilters(mFilters);
+      else if(m_pVideoCodec)
+         mFilters = m_pVideoCodec->SetFilters(mFilters);
+#else
       mFilters = m_pVideoCodec->SetFilters(mFilters);
+#endif
 
+#if defined(HAS_LIBHISICODEC)
+      int iDecoderState;
+      if(m_hwcodec == true)
+         iDecoderState = m_pVideoHWCodec->Decode(pPacket->pData, pPacket->iSize, pPacket->dts, pPacket->pts);
+      else
+         iDecoderState = m_pVideoCodec->Decode(pPacket->pData, pPacket->iSize, pPacket->dts, pPacket->pts);
+#else
       int iDecoderState = m_pVideoCodec->Decode(pPacket->pData, pPacket->iSize, pPacket->dts, pPacket->pts);
+#endif
 
       // buffer packets so we can recover should decoder flush for some reason
+#if defined(HAS_LIBHISICODEC)
+      if(m_hwcodec == false && m_pVideoCodec->GetConvergeCount() > 0)
+#else
       if(m_pVideoCodec->GetConvergeCount() > 0)
+#endif
       {
         m_packets.push_back(DVDMessageListItem(pMsg, 0));
         if(m_packets.size() > m_pVideoCodec->GetConvergeCount()
@@ -603,7 +734,14 @@
             m_messageQueue.Put(msg, iPriority + 10);
           }
 
+#if defined(HAS_LIBHISICODEC)
+          if(m_hwcodec == true && m_pVideoHWCodec)
+             m_pVideoHWCodec->Reset();
+          else if(m_pVideoCodec)
+             m_pVideoCodec->Reset();
+#else
           m_pVideoCodec->Reset();
+#endif
           m_packets.clear();
           picture.iFlags &= ~DVP_FLAG_ALLOCATED;
           g_renderManager.DiscardBuffer();
@@ -639,8 +777,23 @@
         {
 
           // try to retrieve the picture (should never fail!), unless there is a demuxer bug ofcours
+#if defined(HAS_LIBHISICODEC)
+          bool IsPicture = false;
+          if(m_hwcodec == true && m_pVideoHWCodec)
+          {
+             m_pVideoHWCodec->ClearPicture(&picture);
+             IsPicture = m_pVideoHWCodec->GetPicture(&picture);
+          }
+          else if(m_pVideoCodec)
+          {
+             m_pVideoCodec->ClearPicture(&picture);
+             IsPicture = m_pVideoCodec->GetPicture(&picture);
+          }
+          if(IsPicture == true)
+#else
           m_pVideoCodec->ClearPicture(&picture);
           if (m_pVideoCodec->GetPicture(&picture))
+#endif
           {
             sPostProcessType.clear();
 
@@ -735,6 +888,9 @@
               //flushing the video codec things break for some reason
               //i think the decoder (libmpeg2 atleast) still has a pointer
               //to the data, and when the packet is freed that will fail.
+#if defined(HAS_LIBHISICODEC)
+              if(m_hwcodec == false)
+#endif
               iDecoderState = m_pVideoCodec->Decode(NULL, 0, DVD_NOPTS_VALUE, DVD_NOPTS_VALUE);
               break;
             }
@@ -751,6 +907,9 @@
           {
             CLog::Log(LOGWARNING, "Decoder Error getting videoPicture.");
             m_pVideoCodec->Reset();
+#if defined(HAS_LIBHISICODEC)
+            m_pVideoHWCodec->Reset();
+#endif
           }
         }
 
@@ -763,6 +922,9 @@
         CalcDropRequirement(pts, true);
 
         // the decoder didn't need more data, flush the remaning buffer
+#if defined(HAS_LIBHISICODEC)
+        if(m_hwcodec == false)
+#endif
         iDecoderState = m_pVideoCodec->Decode(NULL, 0, DVD_NOPTS_VALUE, DVD_NOPTS_VALUE);
       }
     }
@@ -772,7 +934,14 @@
   }
 
   // we need to let decoder release any picture retained resources.
+#if defined(HAS_LIBHISICODEC)
+  if(m_hwcodec == true && m_pVideoHWCodec)
+     m_pVideoHWCodec->ClearPicture(&picture);
+  else if(m_pVideoCodec)
+     m_pVideoCodec->ClearPicture(&picture);
+#else
   m_pVideoCodec->ClearPicture(&picture);
+#endif
 }
 
 void CDVDPlayerVideo::OnExit()
@@ -1155,6 +1324,11 @@
                     , "CDVDPlayerVideo::OutputPicture");
   }
 
+#if 0 //defined(HAS_LIBHISICODEC)
+  if(m_hwcodec == true)
+  	 return result;
+#endif
+
   // timestamp when we think next picture should be displayed based on current duration
   m_FlipTimeStamp  = iCurrentClock;
   m_FlipTimeStamp += max(0.0, iSleepTime);
diff -Naur kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDPlayerVideo.h kodi.work/xbmc/cores/dvdplayer/DVDPlayerVideo.h
--- kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDPlayerVideo.h	2015-10-23 23:53:21.000000000 +0200
+++ kodi.work/xbmc/cores/dvdplayer/DVDPlayerVideo.h	2016-04-11 09:10:18.912969976 +0200
@@ -137,6 +137,7 @@
   CDVDMessageQueue m_messageQueue;
   CDVDMessageQueue& m_messageParent;
 
+  double m_iCurrentPts; // last pts displayed
   double m_iVideoDelay;
   double m_iSubtitleDelay;
   double m_FlipTimeStamp; // time stamp of last flippage. used to play at a forced framerate
@@ -195,6 +196,10 @@
   // classes
   CDVDStreamInfo m_hints;
   CDVDVideoCodec* m_pVideoCodec;
+#if defined(HAS_LIBHISICODEC)
+  CDVDVideoCodec* m_pVideoHWCodec;
+  bool m_hwcodec;
+#endif
 
   DVDVideoPicture* m_pTempOverlayPicture;
 
diff -Naur kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDStreamInfo.h kodi.work/xbmc/cores/dvdplayer/DVDStreamInfo.h
--- kodi-15.2-02e7013/xbmc/cores/dvdplayer/DVDStreamInfo.h	2015-10-23 23:53:21.000000000 +0200
+++ kodi.work/xbmc/cores/dvdplayer/DVDStreamInfo.h	2016-03-26 15:26:07.089356269 +0100
@@ -56,8 +56,8 @@
 
 
   // VIDEO
-  int fpsscale; // scale of 1001 and a rate of 60000 will result in 59.94 fps
-  int fpsrate;
+  int fpsscale; //12 // scale of 1001 and a rate of 60000 will result in 59.94 fps
+  int fpsrate; //16
   int rfpsscale;
   int rfpsrate;
   int height; // height of the stream reported by the demuxer
@@ -68,8 +68,8 @@
   int level; // encoder level of the stream reported by the decoder. used to qualify hw decoders.
   int profile; // encoder profile of the stream reported by the decoder. used to qualify hw decoders.
   bool ptsinvalid;  // pts cannot be trusted (avi's).
-  bool forced_aspect; // aspect is forced from container
-  int orientation; // orientation of the video in degress counter clockwise
+  bool forced_aspect; //45 // aspect is forced from container
+  int orientation; //48 // orientation of the video in degress counter clockwise
   int bitsperpixel;
   int pid;
   std::string stereo_mode; // stereoscopic 3d mode
